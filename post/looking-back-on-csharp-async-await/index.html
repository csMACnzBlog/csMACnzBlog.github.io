<!DOCTYPE html>
<html lang="en">
    <head>

        <script>
            if(!/blog\.csmac\.nz/.test(window.location.host)) {
                window.location = "https:\/\/blog.csmac.nz\/post\/looking-back-on-csharp-async-await\/";
            }
        </script>

        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name='author' content='Mark Clearwater, csmacnz@csmac.co.nz'>
        <meta name='language' content='EN'>
        <meta name='medium' content='blog'>
        <meta name="google-adsense-account" content="ca-pub-4517187877737982">

    
        <title>Looking Back on C#: async and await - csMACnz&#39;s Blog</title>
        <meta name="description" content="With C# 8 on our doorstep, I figure it is a good time to reflect on recent additions to the language that have come before. There are some great improvements you may have missed, some that I really enjoy using, and some …">
        <meta name='keywords' content='csMACnz, C Sharp'>

        
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Looking Back on C#: async and await"/>
        <meta property="og:description" content="With C# 8 on our doorstep, I figure it is a good time to reflect on recent additions to the language that have come before. There are some great improvements you may have missed, some that I really enjoy using, and some …"/>
        <meta property="og:site_name" content="csMACnz&#39;s Blog"/>
        <meta property="og:url" content="https://blog.csmac.nz/post/looking-back-on-csharp-async-await/"/>
        <meta property="og:image" content="https://csmac.nz/Content/icon/icon.png"/>

        
        <meta name="twitter:card" content="summary"/>
        <meta name="twitter:title" content="Looking Back on C#: async and await"/>
        <meta name="twitter:description" content="With C# 8 on our doorstep, I figure it is a good time to reflect on recent additions to the language that have come before. There are some great improvements you may have missed, some that I really enjoy using, and some …"/>
        <meta name="twitter:image" content="https://csmac.nz/Content/icon/icon.png"/>
        <meta name="twitter:site" content="@csMACnz"/>
        <meta name="twitter:creator" content="@csMACnz"/>
    

        <link rel="apple-touch-icon-precomposed" href="/images/icon/apple-touch-icon-precomposed.png">
        <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/images/icon/apple-touch-icon-72x72-precomposed.png">
        <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/images/icon/apple-touch-icon-114x114-precomposed.png">
        <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/icon/apple-touch-icon-144x144-precomposed.png">
        <link rel="icon" type="image/png" href="/images/icon/icon.png" />
        <link rel='me' type='text/html' href='https://github.com/csMACnz'>

        <script>
            var d_id  = 'csmacnz',
                g_id  = 'G-08VK9VD3ET';
        </script>

        <link rel="stylesheet" type="text/css" href="/css/style.css" />
        <link rel="stylesheet" type="text/css" href="/css/blogstyle.css" />

        <link rel="alternate stylesheet" title="dark-code" type="text/css" href="/css/solarized_dark.css" disabled>
        <link rel="stylesheet" title="light-code" type="text/css" href="/css/github-gist.css" disabled>

        <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4517187877737982"
        crossorigin="anonymous"></script>

        
        
        <script type="application/ld+json">
        {
            "@context" : "https://schema.org",
            "@type" : "Article",
            "publisher": {
                "@type": "Organization",
                "name": "csMACnz&#x27;s Blog",
                "logo": "https:\/\/blog.csmac.nz\/images\/icon\/apple-touch-icon-144x144-precomposed.png"
            },
            "author": {
                "@type": "Person",
                "name": "Mark Clearwater",
                "image": {
                    "@type": "ImageObject",
                    "url": "//www.gravatar.com/avatar/c97410951ec3738a3fd4a2dfb17a5d9c?d=404&s=250",
                    "width": 440,
                    "height": 295
                },
                "url": "https:\/\/blog.csmac.nz",
                "sameAs": [
                    "https://csmac.nz"
                ]
            },
            "articleSection" : "post",
            "name" : "Looking Back on C#: async and await",
            "headline" : "Looking Back on C#: async and await",
            "url" : "https:\/\/blog.csmac.nz\/post\/looking-back-on-csharp-async-await\/",
            "datePublished": "2019-06-24T06:00:00.000Z",
            "dateModified" : "2019-06-24T06:00:00.000Z",
            "image" : {
                "@type": "ImageObject",
                "url": "https:\/\/images.unsplash.com\/photo-1502426899022-660e3522a15a?ixlib=rb-1.2.1\u0026q=80\u0026fm=jpg\u0026crop=entropy\u0026cs=tinysrgb\u0026w=1080\u0026fit=max\u0026ixid=eyJhcHBfaWQiOjE2ODI3fQ",
                "width": 440,
                "height": 295
            },
            "keywords" : [ "C Sharp" ]
            "description" : "With C# 8 on our doorstep, I figure it is a good time to reflect on recent additions to the language that have come before. There are some great improvements you may have missed, some that I really enjoy using, and some I consider have reached canonical usage status that I think are all worth some reflection.\nMultithreaded programming has always been a difficult thing to get your head around, and there are many pitfalls easily stumbled into.",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "https:\/\/blog.csmac.nz"
            }
            "inLanguage" : "en-US",
            "author" : "Mark Clearwater",
            "creator" : "Mark Clearwater",
            "accountablePerson" : "Mark Clearwater",
            "copyrightHolder" : "Mark Clearwater",
            "copyrightYear" : "2019",
            "wordCount" : "1374",
        }
        </script>
        
        
        
    </head>
    <body class="blog">
        <div class="page-area">

            <header class="header-area">
                <h1 class="header-area-title">csMACnz</h1>
            </header>
            <nav class="navigation-area header-bar-parent">
                <div class="header-bar header-bar-blog">
                    <ul class="menu">
                        <li class="menu-item"><a class="menu-item-content" href="https://csmac.nz">Home</a></li>
                        <li class="menu-item"><a class="menu-item-content" href="https://csmac.nz/baconvaders">Bacon Vaders</a></li>
                        <li class="menu-item"><a class="menu-item-content CurrentButton" href="https://blog.csmac.nz">Blog</a></li>
                        <li class="menu-item"><a class="menu-item-content" href="https://csmac.nz/metablog">Meta</a></li>
                    </ul>
                </div>
            </nav>

            <div id="content" class="content-area">

<!--Page Content Begins-->

<article>
    <div class="content-box" itemscope itemtype=" https://schema.org/Article"><span class="post-meta"><time datetime="2019-06-24"  itemprop="datePublished">24 Jun 19</time> in <a href="/categories/software-engineering">Software Engineering</a> on <a href="/tags/c-sharp">C Sharp</a></span>
<h1 class="post-title" itemprop="headline">Looking Back on C#: async and await</h1>
    
        <section class="post-content"  itemprop="articleBody">
            <img class="post-image" src="https://images.unsplash.com/photo-1502426899022-660e3522a15a?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=1080&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjE2ODI3fQ"><p>With C# 8 on our doorstep, I figure it is a good time to reflect on recent additions to the language that have come before. There are some great improvements you may have missed, some that I really enjoy using, and some I consider have reached canonical usage status that I think are all worth some reflection.</p>
<p>Multithreaded programming has always been a difficult thing to get your head around, and there are many pitfalls easily stumbled into. To help combat this, Microsoft gave us async/await in C#.</p>
<p>Async/Await is a language feature that has been around since Visual Studio 2012 and C# 5 and hides a bunch of the boilerplate state machine code required to safely park a logical thread of execution while it waits for some work to complete or to respond from another thread, IO, or network device.  This allows code to be more logically procedural and linear, therefore easier to read and comprehend.</p>
<p>Since it first came out there has been a raft of improvements across different versions of C#.</p>
<h2 id="the-basics">The basics</h2>
<p>The foundation of how it all works rests on the shoulders of a Library, the Task Parallel Library, or TPL. Tasks have been around since 2010 and were part of the .Net 4 Framework. Similar to what <a href="https://developers.google.com/web/fundamentals/primers/promises">Promises provide in javascript</a>, this library allowed a logical chain of execution across waiting for blocking or longrunning execution while releasing the UI thread from being blocked. This was the introduction of <code>TaskFactory</code> and <code>Task</code>, in a fairly similar form to what we have today.  This was a huge improvement from the days of callback chaining because it reduced heavy nesting of lambdas into more of a linear pipeline and a clear place for error handling to take place.</p>
<p>When C# 5 introduced async/await as a first-class language feature, it was able to leverage the library and extend on it to give us more readable code. It even handled Exceptions by throwing them in the place where <code>await</code> appeared, making <code>try/catch</code> blocks useful in asynchronous code.</p>
<p>What does async/await look like in C# 5?</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span><span style="color:#75715e">// A classic synchronous method</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">string</span> MakeAWebRequest(Uri uri)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// WebClient has synchronous methods, but it is recommended to use HttpClient for newer apps</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">new</span> WebClient();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> client.DownloadString(uri);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// It&#39;s async younger brother</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task&lt;<span style="color:#66d9ef">string</span>&gt; MakeAWebRequestAsync(Uri uri)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// I use WebClient again for better comparing. Use HttpClient!</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> client = <span style="color:#66d9ef">new</span> WebClient();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">await</span> client.DownloadStringAsync(uri);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are two distinctive features in this comparison. The return type is wrapped in a <code>Task&lt;T&gt;</code>, and there is a keyword <code>async</code> on the method signature with <code>await</code> beside method calls that return <code>Task&lt;T&gt;</code> results. Otherwise, the linear execution flow is largely unchanged.</p>
<p>You can easily use the return type without the keywords. In this case, the code works and operates as normal, passing object references around without any async state. The result object captures the state required for the caller to do the asynchronous work in the future, or respond to its completion.  However, if you do use <code>async</code> and <code>await</code>, then you should always return either <code>Task</code> (where usually returns void) or <code>Task&lt;T&gt;</code> (where usually returns T). (In my opinion, there are no reasons left to ever do async without Task - there used to be but not anymore.)</p>
<p>Now we have that out of the way, let&rsquo;s move forward to C# 6 and beyond!</p>
<h2 id="async-and-exceptions">Async and Exceptions</h2>
<p>Exception handling was a big part of this feature on day one. You could simply wrap your async calls in a <code>try{}catch{}</code> and it would work as you would expect it to. The task you are awaiting throws an Exception, your catch triggers.</p>
<p>But initially, this did not work inside the catch or finally blocks in any expected way. In fact, it caused a compiler error. In C# 6 await in <code>catch</code>/<code>finally</code> blocks were given proper compiler support to do the right thing.</p>
<p>Using the example from <a href="https://github.com/dotnet/roslyn/wiki/New-Language-Features-in-C%23-6#await-in-catch-and-finally-blocks">The new language feature docs</a> directly:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>Resource res = <span style="color:#66d9ef">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    res = <span style="color:#66d9ef">await</span> Resource.OpenAsync(<span style="color:#960050;background-color:#1e0010">…</span>);       <span style="color:#75715e">// You could do this.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">…</span>
</span></span><span style="display:flex;"><span>} 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">catch</span>(ResourceException e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">await</span> Resource.LogAsync(res, e);         <span style="color:#75715e">// Now you can do this …</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">finally</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (res != <span style="color:#66d9ef">null</span>) <span style="color:#66d9ef">await</span> res.CloseAsync(); <span style="color:#75715e">// … and this.</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="async-and-console-apps">Async and Console Apps</h2>
<p>The language version was C# 7. We had async everywhere, and the <code>NetStandard</code>s and Frameworks were full of async API calls and interfaces. It was a contagious thing, and you really had to jump through hoops to try <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">to call a red function from a blue one</a>.</p>
<p>And then there was main. That pesky little entry point into your application. The one the compiler generates for you that kicks off all of the application execution. The one that had to call into your top-most async method to <code>RunAsync</code>. And it had to be <code>public static void Main(string[] args)</code> or <code>public static int Main()</code>. That is not an async method.</p>
<p>Luckily, with the first ever minor language update, C# 7.1, we were given the mighty and powerful async main!</p>
<pre tabindex="0"><code>// You can finaly use Task&lt;int&gt;!
public static async Task&lt;int&gt; Main()
{
...
}

// Also available in no return value flavour!
public static async Task Main()
{
...
}
</code></pre><h2 id="async-and-tests">Async and Tests</h2>
<p>We have a tonne of async methods in our system. But we should also be testing that code.  And our testing frameworks were synchronous.</p>
<p>Luckily our testing frameworks have finally caught up, and with XUnit we can write tests that return Task and are async<code>, and we also have the </code>IAsyncLifetime` interface.</p>
<pre tabindex="0"><code>// This is what we had to do to test async
public class MyTestCase
{
    private readonly MyClass _systemUnderTest;

    public MyTestCase()
    {
        _systemUnderTest = MyClass();
        
        Task.Run(async () =&gt; await _systemUnderTest.Init()).GetAwaiter().GetResult();
    }
    
    public void CanRunSuccessfully()
    {
    
        var result = Task.Run(async () =&gt; await _systemUnderTest.Run()).GetAwaiter().GetResult();
        
        Assert.True(result);
    }
}
</code></pre><p>Using <code>Task.Run</code> and <code>GetAwaiter</code> or other synchronising methods can be very error-prone, and <a href="https://blog.stephencleary.com/2012/07/dont-block-on-async-code.html#preventing-the-deadlock">prone to deadlocks</a>. Avoiding these is the best approach always (though still not always avoidable).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cs" data-lang="cs"><span style="display:flex;"><span>The best way to tet with <span style="color:#66d9ef">async</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyTestCase</span> : IAsyncLifetime
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> MyClass _systemUnderTest;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> MyTestCase()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _systemUnderTest = MyClass();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task InitializeAsync()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">await</span> _systemUnderTest.Init();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Task DisposeAsync()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Task.CompletedTask;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">async</span> Task CanRunSuccessfully()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>   
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> result = <span style="color:#66d9ef">await</span> _systemUnderTest.Run();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        Assert.True(result);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I&rsquo;m not sure if other test runners are able to handle async as well as XUnit does, so I always just use XUnit.</p>
<h2 id="valuetask">ValueTask</h2>
<p>The original implementation of the async/await language feature was strongly tied to the <code>Task</code> and `Task<T> types.</p>
<p>In C# 7, the language feature was enhanced, similar to other features, to use a pattern based on method signatures (like the <a href="/looking-back-on-csharp6-initializers/">Add for the initialiser syntax</a>). Specifically, the <code>GetAwaiter</code> method must be available on the type used with the <code>await</code> keyword.</p>
<p>Along with this change was the introduction of a new type to leverage this pattern, <code>ValueTask</code>. A <code>ValueTask</code> is a value type (struct) that will be stack-allocated and copied by value. If your method uses caching, and most of the time returns a simple value instead of an awaited execution, the <code>ValueTask</code> may be more efficient than the <code>Task</code> type.</p>
<p>This is because the overheads of Heap-allocation of the reference type <code>Task</code> can have an impact on performance. If you detect this as an issue, you can use the new <code>ValueTask</code> instead. This will be a stack-allocated value type containing the response value and copied around.</p>
<p>Guidance for this: if you mostly return a value, but occasionally call an actual asynchronous IO execution, <code>ValueTask</code> will probably add value (e.g. heavy result caching). If you actually await most of the time, <code>Task</code> should be fine. As usual, measure and test before making the change arbitrarily.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Async programming is becoming the canonical way of building apps with IO in most languages. And in practice, most of the apps I write are IO-bound apps. C# and dotnet make this simple with <code>async/await</code> and the language keeps improving our experience using this successfully. This is a must-use feature that is unavoidable, but knowing the limitations and extensions available to use it well is still very important to do. Use it, but make sure you know enough about how it works to use it well.</p>
</section>
        
        <section class="share">
            Share: 
            <a class="icon-twitter" href="https://twitter.com/share?text=Looking%20Back%20on%20C%23%3a%20async%20and%20await&url=https%3a%2f%2fblog.csmac.nz%2fpost%2flooking-back-on-csharp-async-await%2f"
                onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                <span>Twitter</span>
            </a>
            |
            <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fblog.csmac.nz%2fpost%2flooking-back-on-csharp-async-await%2f"
                onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                <span>Facebook</span>
            </a>
        </section>
    </div>
    <div class="content-box">
        
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = d_id; 
            var disqus_title = 'Looking Back on C#: async and await';
            
             
            (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
    </div>
</article>

<!--Page Content Ends-->

            </div><aside class="sidebar-area">

<!--Sidebar Content Begins-->

                <div class="header-bar-parent sidebar-item">
                    <div class="header-bar header-bar-mastodon">Mastodon</div>
                    
                    
                    <iframe allowfullscreen sandbox="allow-top-navigation allow-scripts" width="280" height="400" src="https://maplefeed.bihlink.com/apiv2/feed?userurl=https%3A%2F%2Fmastodon.nz%2F%2Fusers%2Fcsmacnz&theme=modern-light&size=80&header=true&replies=false&boosts=false"></iframe>
                    
                </div>


                <div class="header-bar-parent sidebar-item">
                    <div class="header-bar header-bar-rss">Subscribe</div>
                    
                    <a href="/rssfeeds/" title="csMACnz's Blog">RSS Feeds</a>
                    <a href="https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Ffeeds.feedburner.com%2FcsmacnzBlog" target="_blank" title="csMACnz&amp;#039;s Blog"><img src="https://s3.feedly.com/feedburner/feedly.png" alt="" style="border:0"/></a>
                    <br />
                    <a href="https://www.patreon.com/csMACnz" target="_blank"><img src="/images/patreon.png" /></a>
                    
                    
                </div>


                <div class="header-bar-parent sidebar-item">
                    <div class="header-bar header-bar-xbox">Gamercard</div>
                    

                    <div>
                        <a href="https://www.exophase.com/xbox/user/csMACnz/"><img width="288px" src="https://card.exophase.com/1/1476805.png"></a>
                        <a href="http://steamcommunity.com/id/csMACnz/" target="_blank"><img src="https://www.steamsignature.com/status/english/76561197994712512.png" alt="" title="csMACnz's Steam Profile" /></a>
                    </div>
                    
                </div>


                <div class="header-bar-parent sidebar-item">
                    <div class="header-bar header-bar-ads">Advertisement</div>
                    
                    <div>
                        
                        <ins class="adsbygoogle"
                            style="display:block"
                            data-ad-client="ca-pub-4517187877737982"
                            data-ad-slot="3618449993"
                            data-ad-format="auto"
                            data-full-width-responsive="true"></ins>
                        <script>
                            (adsbygoogle = window.adsbygoogle || []).push({});
                        </script>
                    </div>
                    
                </div>

<!--Sidebar Content Ends-->

            </aside>

            <footer class="footer-area">

            <p>
                Designed and Maintained by Mark Clearwater; Last updated August 2021.
                <!-- This used to be something useful, now it is just a hack I left it to make layout easier but also as a fun reminder for me of what it used to be -->
                <br /><a class="footer-link" >¯\_(ツ)_/¯</a>
            </p>

            </footer>
        </div>

<!--body scripts Begins-->

        
        <script src="/js/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>

        <script src="/js/codetoggle.js"></script> 

        
        <script src="/js/htmx.min.js"></script>

        
        <script async src="https://www.googletagmanager.com/gtag/js?id="+g_id></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', g_id);
        </script>

        <script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>

<!--body scripts Ends-->


<!-------------------------------->
<!--                            -->
<!--  _(\    |@@|               -->
<!-- (__/\__ \--/ __            -->
<!--    \___|----|  |   __      -->
<!--        \ }{ /\ )_ / _\     -->
<!--        /\__/\ \__O (__     -->
<!--       (--/\--)    \__/     -->
<!--       _)(  )(_             -->
<!--      `---''---`            -->
<!--                            -->
<!-- https://github.com/csMACnz -->
<!-------------------------------->

    </body>
</html>
