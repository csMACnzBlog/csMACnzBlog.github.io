<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dotnetcore on csMACnz&#39;s Blog</title>
    <link>https://csmacnzblog.github.io/categories/dotnetcore/</link>
    <description>Recent content in dotnetcore on csMACnz&#39;s Blog</description>
    <image>
      <url>https://csmacnzblog.github.io/favicon.png</url>
      <title>csMACnz&#39;s Blog</title>
      <link>https://csmacnzblog.github.io</link>
    </image>
    <ttl>1440</ttl>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-nz</language>
    <lastBuildDate>Sun, 26 Jul 2020 02:00:00 +0000</lastBuildDate><atom:link href="https://csmacnzblog.github.io/categories/dotnetcore/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nullable and notnull Serialisation Properties</title>
      <link>https://csmacnzblog.github.io/post/nullable-and-notnull-serialisation-properties/</link>
      <pubDate>Sun, 26 Jul 2020 02:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/nullable-and-notnull-serialisation-properties/</guid>
      <description><p>The C# 8 feature Nullable has been well received by myself and others into our workflows and has improved code bases immensely.  However, there is one niggly workaround that I&rsquo;m not a fan of, and that is <code>= default!;</code></p>
<h2 id="problem-definition">problem definition</h2>
<pre><code class="language-cs">// This class is used to serialise/deserialise a payload from a server
public class MyContractDTO
{
    public string Value { get; set; } = default!;
}
</code></pre>
<p>My codebase is now littered with this code hack to get it to compile because nullable says it can&rsquo;t guarantee that this property is not null.</p>
<p>Let&rsquo;s take a closer look at what we are saying.</p>
<pre><code class="language-cs">
// With the Nullable feature enabled, I need to ensure Value is not null:
// - either in the constructor from a notnull argument
// - or giving it a default non-null value.
public string Value { get; set; }

// Initialise the property to its default value (which for reference types like string is null)
public string Value { get; set; } = default;

// The '!' says to treat the value as if it is notnull, the developer knows better
public string Value { get; set; } = default!;
</code></pre>
<p>What does this achieve? Well, the compiler ignores the fact that it could be null, and we initialise it to be null. This is a contradiction if ever I saw one, and I don&rsquo;t like it.</p>
<h2 id="normal-solutions">Normal solutions</h2>
<p>There are two solution paths to take here:</p>
<ul>
<li>Acknowledge that it might be null and make it nullable.</li>
<li>Initialise in the constructor.</li>
</ul>
<p>These work great with normal codebases and in some cases, one is better than the other.  If you know it certainly can be null, use the first option. If you know you never expect or want it to be null, use the second.</p>
<p>Bonus points once you have the constructor is to make the type immutable.
For all domain and application logic, This is what I have done successfully so far and will continue doing.</p>
<h2 id="but-serialisation">But serialisation</h2>
<p>Here is the problem. Serialisation.</p>
<p>When we have a type that is going to be used to deserialise transport models we again have the same choices as above, but a few more points to consider.</p>
<ul>
<li>The JSON may or may not include the field</li>
<li>The JSON may have the field set to null</li>
<li>The Deserialiser might not support constructors</li>
<li>The Deserialiser doesn&rsquo;t know about Nullable and can&rsquo;t ensure the safety is upheld.</li>
</ul>
<p>Again we can make the call to acknowledge that it might be null and make it nullable.  But there are drawbacks here. If you do this, you have to add all the error-handling for dealing with nullable checks. And if you control both server and client in this situation, then you might be writing and testing code for something you never plan to, nor may never need to ever support. Being null is an exceptional/fatal situation you don&rsquo;t want to have to constantly guard against.</p>
<p>Which leads us back to the de-facto solution currently being advocated and used:</p>
<pre><code class="language-cs">public string Value { get; set; } = default!;
</code></pre>
<p>I&rsquo;m still not happy. So why don&rsquo;t we work on that?</p>
<h2 id="the-json-may-or-may-not-include-the-field-or-it-might-be-null">The JSON may or may not include the field or it might be null</h2>
<p>Luckily for us, this concern is fairly easy to address. Say we are using Newtonsoft.Json and want this extra piece of reassurance.</p>
<pre><code class="language-cs">[JsonProperty(Required = Required.Always)]
public string Value { get; set; } = default!;
</code></pre>
<p>The <code>Required</code> attribute annotation is designed for exactly this situation. When we use Newtonsoft.Json as our deserialiser, we can get a <code>JsonSerializationException</code> for free.</p>
<p>This ensures we:</p>
<ul>
<li>have minimal code doing the null checking</li>
<li>don&rsquo;t have to guard every access to a nullable property</li>
<li>Treat null or missing as fatal errors as part of an existing serialisation error handling process (which we should always have anyway).</li>
</ul>
<p>This still doesn&rsquo;t stop any other piece of code from creating an invalid object state, though. But this may be the easiest solution to add those missing guarantees alongside using <code>default!</code>.</p>
<h2 id="use-constructors">Use Constructors</h2>
<p>Newtonsoft.Json helps once again by supporting constructors. Make sure all the mandatory non-nullable properties are in the constructor. And as long as there is no default constructor (which when doing nullable right you can&rsquo;t anyway) and the constructor parameters have names matching the properties, this just works as expected.</p>
<pre><code>public class MyContractDTO
{
    public MyContractDTO(string value)
    {
        if(value is null) throw new ArgumentNullException(nameof(value));
        Value = value;
    }
    
    public string Value { get; set; };
}
</code></pre>
<p>You do however have to write your null-guard into the constructor to ensure it fails with an appropriate error message. Without this, null might still sneak through, even if you annotate the property.</p>
<p>Once more, Newtonsoft.Json with constructors also means support for read-only (immutable) objects.</p>
<h2 id="what-about-not-using-newtonsoftjson">What about not using Newtonsoft.Json?</h2>
<p>There is a new kid on the block - <code>System.Text.Json</code>. However, this is one area where it doesn&rsquo;t shine so bright compared to Newtonsoft.Json.</p>
<p>Pretty much none of the above works. Constructors are not supported. Required annotation is not supported. Along with many other things.</p>
<p>More on <a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to">what does and does not translate across from Newtonsoft.Json is documented here</a>.</p>
<p>Instead, you will need to write your own converter and manually deserialise your object with your own explicit null checks (which could be done inside the constructor).</p>
<p>For example, given our simple type above, we might do the following:</p>
<pre><code class="language-cs">[System.Text.Json.Serialization.JsonConverter(typeof(MyContractDTOConverter))]
public class MyContractDTO
{
    public MyContractDTO(string value)
    {
        if (value is null) throw new ArgumentNullException(nameof(value));
        Value = value;
    }
    
    public string Value { get; }
}

// Made using the examples given at https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#required-properties
// Your decisions may vary.
// e.g. this only supports {&quot;value&quot;: &quot;...&quot;} format, no extra properties allowed.
// For a more complex object, you would probably be more flexible.
// Better guides here: https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-converters-how-to
public class MyContractDTOConverter : JsonConverter&lt;MyContractDTO&gt;
{
    private readonly JsonEncodedText ValueName = JsonEncodedText.Encode(&quot;value&quot;);

    public override Implementation Read(
        ref Utf8JsonReader reader,
        Type typeToConvert,
        JsonSerializerOptions options)
    {
        if (reader.TokenType != JsonTokenType.StartObject)
        {
            throw new JsonException();
        };

        string? value = default;

        reader.Read();
        // One property must exist
        if (reader.TokenType != JsonTokenType.PropertyName)
        {
            throw new JsonException();
        }

        // That property must have the right name
        if (reader.ValueTextEquals(ValueName.EncodedUtf8Bytes))
        {
            value = ReadProperty(ref reader, options);
        }
        else
        {
            throw new JsonException();
        }

        reader.Read();
        // There must be no other properties
        if (reader.TokenType != JsonTokenType.EndObject)
        {
            throw new JsonException();
        }

        return new MyContractDTO(value);
    }

    private string ReadProperty(ref Utf8JsonReader reader, JsonSerializerOptions options)
    {
        Debug.Assert(reader.TokenType == JsonTokenType.PropertyName);

        reader.Read();

        return reader.GetString();
    }

    private void WriteProperty(Utf8JsonWriter writer, JsonEncodedText name, string stringValue, JsonSerializerOptions options)
    {
        writer.WritePropertyName(name);
        writer.WriteStringValue(stringValue);
    }

    public override void Write(
        Utf8JsonWriter writer,
        Implementation implementation,
        JsonSerializerOptions options)
    {
        writer.WriteStartObject();
        WriteProperty(writer, ValueName, implementation.Value, options);
        writer.WriteEndObject();
    }
}
</code></pre>
<p>At which point you now have a bunch more code and logic to look after, but can achieve the same/similar results to what Newtonsoft.Json could do. Depending on your situation, maintaining this code may be more effort than declaring it nullable and maintaining checks around that in consuming code. Up to you.</p>
<h2 id="decisions-decisions">Decisions, Decisions</h2>
<p>So what would I recommend?</p>
<p>Firstly, don&rsquo;t just use <code>default!</code> on your serialised types.</p>
<p>For maximum effect, make your classes have constructors for notnull values, and maybe even make your properties Immutable, if that makes sense. Have your constructors guard against nulls so that your compile-time assurances have runtime verifications. Especially is this is a client library you provide to others.</p>
<p>If you are using Newtonsoft.Json you should at least apply the <code>[JsonProperty(Required = Required.Always)]</code> to all your notnull properties. But add the constructors as well because you can. If you can stick with Newtonsoft.Json, your life will be very easy.</p>
<p>If you are using (or have to use) System.Text.Json, write custom converters for your types so that you can have those constructors mentioned above. Make sure you keep them flexible enough to ignore any extra properties you might add in the future to avoid breaking backwards compatibility.</p>
<p>This experiment has a companion GitHub repo of tests (a mixture of proof they work, and proof they fail tests) <a href="https://github.com/csMacnzBlog/NullableSerialisationExperiments">available here</a>.</p>
<p>Happy Null-Hunting.</p>
</description>
    </item>
    
    <item>
      <title>Microsoft and dotnet: 4 is the new 9</title>
      <link>https://csmacnzblog.github.io/post/untitled-4/</link>
      <pubDate>Mon, 08 Jul 2019 22:54:03 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/untitled-4/</guid>
      <description><p>Dotnet core 3.0 is about to drop, but we already have lots of information about vnext specifically that it&rsquo;s going to be dotnet 5.</p>
<p>It wasn&rsquo;t that many years ago that Microsoft seemingly forgot how to.count. Windows 8 with all its modern UI was succeeded with not Windows 9, but instead a version named Windows 10. Not sure what the aversion to the number 9 was, buta they are up to their old tricks again with .Net.</p>
<p>Once dotnet Core 3 drops we already know that the next version will be called .Net 5. The number 4 is getting the same treatment as 9.</p>
<p>The reality is not just a simple arithmetic error. Instead, it is part of a larger reunification story of C# and .Net in general.</p>
<p>For those of you still building .Net Full Framework apps for Desktop, Windows Services and IIS may be aware that the rest of the world had started moving to dotnet Core, with version 1,2 and now 3.0 dropping soon. This is not just a reimplementation, but at the same time part of a process to define a standard (a &lsquo;NetStandard&rsquo; you might say) which is a shared set of API code specifications that a runtime implementation can fulfil. These are versioned, have been growing incrementally in cspabilities., and have been implemented by these new dotnet Core implementations, as well as each new minor versioned release of the  .Net Full Framework as well.</p>
<p>But the standard opens up nuget possibilities. We can build nuget libraries that instead of targeting a runtime, can target one of these NetStandard versions instead. This means a Reilly portable library that can be written once, and run on multiple target runtimes. This is also unbounded because any new runtime can use the library providing it also meets the required standard.</p>
<p>And that&rsquo;s where the story gets even more interesting. Have you heard of Mono?</p>
<p>Mono started as a cleanroom implementation of the runtime as a by specification reimplementation on Linux.  What have it legs was its evolution as part of Xamarin, which gave C# a way to run on both IOS and Android devices as well.  And by implementing .NetStandard, mono picked up support for using these new portable Niger packages.</p>
<p>Didi</p>
<p>&hellip;</p>
<p>Unification of core, mono, full framework is dead.</p>
</description>
    </item>
    
    <item>
      <title>Looking forward to dotnet in 2019</title>
      <link>https://csmacnzblog.github.io/post/looking-forward-to-dotnet-in-2019/</link>
      <pubDate>Thu, 17 Jan 2019 20:40:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/looking-forward-to-dotnet-in-2019/</guid>
      <description><p>It&rsquo;s a new year, and we already have a bunch of dotnet releases to look forward to, thanks to the open development processes that Microsoft is using these days with dotnet.</p>
<p>The three big releases I am looking forward to are C# 8 and .Net Core 3.0, and a NetStandard2.1. (Not to mention there is a .Net Framework 4.8 as well. But I&rsquo;ve moved on.)</p>
<h2 id="c-8">C# 8</h2>
<p>It feels like we&rsquo;ve been talking about C# 8 for a while, with 7.1, 7.2 and 7.3 releases building towards it. (It was 2 years ago when they were talking about what&rsquo;s new in C# 7.0!). We&rsquo;ve had demos at Build, NDC and online of what is coming, with <a href="https://blogs.msdn.microsoft.com/dotnet/2018/12/05/take-c-8-0-for-a-spin/">Preview releases</a> dropping towards the end of last year. We should expect to see VS 2019 Released this Quarter (one hopes) and can get a better look at C# 8 in its final form at that point.</p>
<p>What we do know is there are a bunch of cool features coming:</p>
<ul>
<li>Nullable reference types</li>
<li>Async streams</li>
<li>Ranges and indices</li>
<li>Default implementations of interface members</li>
<li>Recursive patterns</li>
<li>Switch expressions</li>
<li>Target-typed new-expressions</li>
</ul>
<p>More detailed notes and examples of what these are and how they look was published on the .Net Blog article <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/">Building C# 8.0</a>.</p>
<p>I am seriously looking forward to the Nullable reference types (I have a few libraries to get updated to support it still), Switch expressions and recursive patterns, and also finding out where the other features start to find their use for me.</p>
<h2 id="net-core-30">.Net Core 3.0</h2>
<p>Once again, we have a proper Major release. This one is as important as the .Net Core 2.0 milestone was, but hopefully, the jump is much more stable. This is an umbrella for new dotnet CLI tool updates, MSBuild updates, a new 3.0 runtime, and support for all in Visual Studio as well.</p>
<p>The big headline is Windows Desktop Coming to .NET Core. Yes, this is OS-specific and not cross-platform, but is a huge step in getting those GUI apps transferred over to the dotnet CLI and the .Net Core runtime. As part of this, they even OpenSourced all the GUI frameworks WPF, WinForms and WinUI.</p>
<p>Things to look out for when moving to .Net Core 3.0:</p>
<ul>
<li>Desktop Applications support</li>
<li>Applications now have executables by default</li>
<li>dotnet build now copies dependencies</li>
<li>Local dotnet tools</li>
<li>ARM64 and updated platform support</li>
<li>Many language and runtime improvements
<ul>
<li>fast in-box JSON Reader</li>
<li>C# 8 language features support</li>
<li>System.Buffers.SequenceReader</li>
<li>IoT improvements</li>
<li>TLS improvements on linux</li>
<li>Cryptography improvements</li>
<li>More BCL Improvements using optimized Span<!-- raw HTML omitted -->, Memory<!-- raw HTML omitted --></li>
<li>Default implementations of interface members</li>
<li>Tiered Compilation on by default</li>
<li>Assembly Metadata Reading with MetadataLoadContext</li>
</ul>
</li>
</ul>
<p>To see more of the changes in detail, especially the language and runtime improvements, you can read up more yourself <a href="https://blogs.msdn.microsoft.com/dotnet/2018/12/04/announcing-net-core-3-preview-1-and-open-sourcing-windows-desktop-frameworks/">in the Announcement from December</a>.</p>
<h2 id="netstandard21">.NetStandard2.1</h2>
<p>The release of .Net Core 2.1 and 2.2 went by without needing to update the baseline of compatibility. The NetStandard2.0 target has stood up well as a baseline common denominator after the false start .NetStandard1.x gave some of us.</p>
<p>Late last year Microsoft <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/05/announcing-net-standard-2-1/">Announced .NET Standard 2.1</a>, which is a new required standard that will be first implemented in .dotnet 3.0 and .Net Framework 4.8 is a foundation to allow using some of the new language features that need Runtime support, such as Async streams, indexers and ranges.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As mentioned, you can start playing with some of this stuff today in the <a href="https://blogs.msdn.microsoft.com/dotnet/2018/12/05/take-c-8-0-for-a-spin/">Preview of Visual Studio 2019</a>.</p>
<p>Plenty of new stuff to learn over the coming year and I can&rsquo;t wait for Release day so I can update everything I have.  First stop will be Nullable reference types.</p>
<p>What are you looking forward to using the most?</p>
</description>
    </item>
    
    <item>
      <title>Speciality NuGet Packing on .Net Core</title>
      <link>https://csmacnzblog.github.io/post/speciality-nuget-packing/</link>
      <pubDate>Mon, 08 Oct 2018 05:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/speciality-nuget-packing/</guid>
      <description><p>I recently wrote about <a href="/nuget-packing-on-linux/">NuGet packing on linux</a> specifically, and want to continue the theme with other things you can do with NuGet packaging.</p>
<p>As a quick recap you can use a .Net Core <code>*.csproj</code> as a wrapper around a <code>*.nuspec</code> file and use <code>dotnet pack</code> to pack it, cross-platform, without needing <code>nuget.exe</code>.</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
    &lt;NuspecFile&gt;mynewapp.nuspec&lt;/NuspecFile&gt;
    &lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;
    &lt;SkipCompilerExecution&gt;true&lt;/SkipCompilerExecution&gt;
    &lt;CopyBuildOutputToOutputDirectory&gt;false&lt;/CopyBuildOutputToOutputDirectory&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;

</code></pre>
<p>(See the <a href="/nuget-packing-on-linux/">other article</a> for more detailed analysis of these properties.)</p>
<p>Now for something new.</p>
<h3 id="contentfiles">ContentFiles</h3>
<p>Do you remember Content files? There was(is?) this feature in NuGet files where you can include files, and have those files automatically added to your .Net Framework applications when the Package is Installed. Some libraries used this to distribute code that could be embedded into your application instead of linking to a library dependency.  Dapper was one example that did this, and I think some logging frameworks also distributed some code this way.</p>
<p>There were a tonne of downsides to this approach. The files were editable, they were put into source control, and they didn&rsquo;t update automatically when you updated the NuGet package.  These might sound like upsides, and they were probably best practice given the circumstances. But from a distributer&rsquo;s point of view, these were downsides.</p>
<p>There were other issues as well, especially now we have dotnet core cli, and we have cross-platform builds. This approach is no longer viable in most situations.</p>
<p>Luckily, there is a replacement to <code>Content</code> files, and that is <code>ContentFiles</code>. <a href="https://blog.nuget.org/20160126/nuget-contentFiles-demystified.html">NuGet ContentFiles Demystified
</a> seems to be the canonical reference post on what these are and how they work, and if you want to read the spec for how to use these with <code>nuspec</code>, that is <a href="https://docs.microsoft.com/en-us/nuget/reference/nuspec#contentfiles">documented here</a>.</p>
<p>How do we make this work with <code>dotnet pack</code> without using the <code>nuspec</code> trick above? Say you are already packaging a DLL, and want to add an extra file to the mix?  Here is the answer:</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup&gt;
    &lt;Compile Remove=&quot;IncludedFile.cs&quot; /&gt;
    &lt;Content Include=&quot;IncludedFile.cs&quot; BuildAction=&quot;Compile&quot; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>Let&rsquo;s say this is an application with a bunch of source files. We have one source file that rather than compile it in, we want to include into the project that uses the package at compile time.  First, we remove our file from compiling inside our app, then we make it <code>Content</code>.  By default, any <code>Content</code> files will become <code>contentFiles</code> in the NuGet package.  It is that easy.</p>
<p>There is one cool trick you can do here, too. if you call your file <code>*.cs.pp</code>, you can run transforms over it. The most (and only) useful one for us is the namespace placeholder. Anywhere in the file you write <code>$rootnamespace$</code> it will be replaced by the namespace of the project that imports the package, before that library compiles this file. Very handy to ensure that the user&rsquo;s own namespace is used when compiling this file.</p>
<p>A few notes:</p>
<ul>
<li>If the code in that file doesn&rsquo;t compile, consumers will not be able to compile their application (maybe look at using <a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/">preprocessor directives</a> for different framework targets.</li>
<li>Clients need to include <code>contentfiles</code> Assets when they reference the library or they won&rsquo;t get the files, and they can also use that feature to explicitly turn that off. Document this for them. (specifically <code>&lt;IncludeAssets&gt;contentfiles;&lt;/IncludeAssets&gt;</code>, but <code>IncludeAssets</code> is set to include all asset types by default anyway.)</li>
<li>The <code>contentFiles</code> are included per language, per framework, based on the <code>TargetFramework</code> you are building against (the same way the DLLs do). This means the files will only work with the same language as the project (by default) and the same target frameworks by default. My understanding is that this still follows the usual highest compatible resolution.</li>
<li>If you don&rsquo;t want your NuGet to pack content files, you can use the <code>&lt;IncludeContentInPack&gt;false&lt;/IncludeContentInPack&gt;</code> setting to turn that feature off completely.</li>
<li>you can set <code>Pack=&quot;false&quot;</code> onto a Content element to exclude it from packaging as one of the contentFiles. You can also set <code>Pack=&quot;true&quot;</code> on None and Compile elements as well for them to be included the same way.
As well as BuildAction <code>Compile</code>, there are a couple of others: <code>Content</code>, <code>None</code>, <code>Embedded Resource</code>. The same way you can define a file to be one of these in your <code>csproj</code>, the project that includes your <code>contentFiles</code> will have them set to that specified item type.  <code>Content</code> might be useful if you want a file to be copied to their build output folder for some reason. I can&rsquo;t seem to think of a valid reason for <code>None</code>, though.</li>
</ul>
<p>It turns out it is that simple to do <code>contentFiles</code> out of the box.</p>
<h3 id="build-props-and-targets">build props and targets</h3>
<p>You can arbitrarily include any file into any location in the NuGet package if you like. There is a special folder called <code>build</code> that contains props and targets to extend MSBuild. For instance, we might want to have a props file</p>
<pre><code>&lt;None Include=&quot;MyNewApp.props&quot; PackagePath=&quot;build/$(TargetFramework)&quot; Pack=&quot;true&quot; /&gt;
</code></pre>
<p>If you wanted the same file to work for all targets, you could simply just use <code>PackagePath=&quot;build&quot;</code>.</p>
<p>When using props and targets, you want your entry file to be the same name as the project/package, so that it will get loaded by the project that consumes your NuGet package.</p>
<p>More about how the <code>nuspec</code> file is supposed to look for props and targets <a href="https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package#including-msbuild-props-and-targets-in-a-package">can be found here</a>.</p>
<p>Note they recommend using a min client version to let clients know you are using this feature:</p>
<pre><code>&lt;PropertyGroup&gt;
    &lt;MinClientVersion&gt;2.5&lt;/MinClientVersion&gt;
&lt;/PropertyGroup&gt;
</code></pre>
<p>And with that, you can now augment the build props and tasks in your consumers' projects, and use this approach to include any arbitrary files into your NuGet package.</p>
<h3 id="metadata-properties">Metadata properties</h3>
<p>The nice thing about using a <code>csproj</code>, is that with this one file you can set all your assembly metadata, as well as NuGet package metadata.</p>
<p>The <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/csproj#nuget-metadata-properties">Additions to the csproj format</a> page gives a great overview of (among other things) all the possible properties you can put into your <code>csproj</code> files, and where exactly these will go into your file NuGet package metadata. This is the final piece that ensures you don&rsquo;t actually have to hand-craft a <code>nuspec</code> file at all and can keep all your pack information inside the <code>csproj</code> file instead.</p>
<h3 id="summary">Summary</h3>
<p>If you follow everything here, you should get a <code>csproj</code> file that:</p>
<ul>
<li>Contains all your project and package metadata</li>
<li>Can include, or exclude a compiled DLL from source code</li>
<li>Can include <code>contentFiles</code> including <code>Compile</code> sources, and <code>EmbeddedResource</code> files</li>
<li>Can include build props and targets to condition how the consumer&rsquo;s build will run</li>
</ul>
<p>Happy Hacking those NuGet packages!</p>
</description>
    </item>
    
    <item>
      <title>NuGet Packing on Linux</title>
      <link>https://csmacnzblog.github.io/post/nuget-packing-on-linux/</link>
      <pubDate>Mon, 01 Oct 2018 05:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/nuget-packing-on-linux/</guid>
      <description><p>For anyone who has been cutting-edge with .Net for a while will know that the nuget.exe runs under mono. And that you can use nuget.exe to package <code>*.nuspec</code> files into <code>*.nupkg</code> files.</p>
<p>Anyone who has been doing dotnet cross-platform will also know that you can use <code>dotnet pack</code> on both Windows and Linux to package your project into a NuGet package containing the <code>dll</code>. It even does references and multi-targeting correctly out of the box.</p>
<p>But did you know that you can also use dotnet pack to package any arbitrary <code>nuspec</code> file as well?</p>
<p>First, let&rsquo;s look at a simple <code>nuspec</code> file that only has package references (an aggregate package).</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;package xmlns=&quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;&gt;
  &lt;metadata&gt;
    &lt;id&gt;MyNewApp&lt;/id&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;authors&gt;csMACnz&lt;/authors&gt;
    &lt;description&gt;An aggregate package example&lt;/description&gt;
    &lt;tags&gt;utils example&lt;/tags&gt;

    &lt;dependencies&gt;
      &lt;dependency id=&quot;Newtonsoft.Json&quot; version=&quot;11.0.2&quot; /&gt;
      &lt;dependency id=&quot;Beefeater&quot; version=&quot;0.5.0&quot; /&gt;
    &lt;/dependencies&gt;
  &lt;/metadata&gt;
  &lt;files&gt;
    &lt;!-- empty files tag avoids copying all files --&gt;
  &lt;/files&gt;
&lt;/package&gt;
</code></pre>
<p>We could use <code>nuget.exe pack</code> but that wouldn&rsquo;t work on Linux. Instead, we create a csproj file designed to do the pack for us in a standard <code>dotnet pack</code> kind of way.</p>
<pre><code class="language-xml">&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
    &lt;NuspecFile&gt;newapp.nuspec&lt;/NuspecFile&gt;
    &lt;NuspecProperties&gt;&lt;/NuspecProperties&gt;
    &lt;NuspecBasePath&gt;&lt;/NuspecBasePath&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>The magic is these three properties (only one required, really):</p>
<ul>
<li><code>&lt;NuspecFile&gt;</code> - Required to tell dotnet to use the hand-crafted <code>nuspec</code> file</li>
<li><code>&lt;NuspecProperties&gt;</code> - (Optional) ability to generate and send <code>nuspec</code> <a href="https://docs.microsoft.com/en-us/nuget/reference/nuspec#replacement-tokens">replacement tokens</a></li>
<li><code>&lt;NuspecBasePath&gt;</code> - (Optional) relative base path to use for pack files (defaults to project folder)</li>
</ul>
<p>For more details on all the things you can put into a <code>nuspec</code> file, check out the docs: <a href="https://docs.microsoft.com/en-us/nuget/reference/nuspec">https://docs.microsoft.com/en-us/nuget/reference/nuspec</a></p>
<p>But we don&rsquo;t stop there. If you run this you will see that we are still building our empty project. We can do a couple of things here.</p>
<ul>
<li><code>&lt;NoBuild&gt;true&lt;/NoBuild&gt;</code> - Adding this will stop the build step being run during pack</li>
<li><code>&lt;GeneratePackageOnBuild&gt;true&lt;/GeneratePackageOnBuild&gt;</code> - We can instead tell <code>dotnet build</code> to run the pack as well.</li>
</ul>
<p>One of these two scenarios may suit you better. It depends.</p>
<p>Using the above settings, you can basically produce any kind of NuGet package you want.</p>
<p>For one last piece of tidy-up, you can disable the compile and remove the dll from the build output entirely:</p>
<ul>
<li><code>&lt;SkipCompilerExecution&gt;true&lt;/SkipCompilerExecution&gt;</code> - (Optional) disable compile entirely</li>
<li><code>&lt;CopyBuildOutputToOutputDirectory&gt;false&lt;/CopyBuildOutputToOutputDirectory&gt;</code> - stop the dll output to the output folder.</li>
</ul>
<p>Unfortunately, at this stage I am still yet to find a reasonable way to remove the need for <code>&lt;TargetFramework&gt;</code>, but something I am still experimenting with. There is a chance that if you are really customising your MSBuild commands, you would end up leveraging the <code>dotnet restore</code>, and that requires a TargetFramework anyway, so not a big deal.</p>
</description>
    </item>
    
    <item>
      <title>HostBuild your dotnet Consoles like you WebHostBuild your web apps.</title>
      <link>https://csmacnzblog.github.io/post/hostbuild-your-dotnet-consoles-like-you-webhostbuild-your-web-apps/</link>
      <pubDate>Mon, 17 Sep 2018 06:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/hostbuild-your-dotnet-consoles-like-you-webhostbuild-your-web-apps/</guid>
      <description><p>I wrote a while back on getting your <a href="https://blog.csmac.nz/a-windows-service-on-dotnet/">Windows Services building with .Net Core</a> which is a nice way to use the new SDK pipeline but still host on Windows without much fuss.</p>
<p>But what If you like the approach but want to run on Linux?</p>
<p>Well after some stumbling around in the dotnet core docs, I found information about <code>HostBuilder</code>, which looks a lot like the <code>WebHostBuilder</code> and <code>WebHost</code> that we use with AspNetCore.  And that is no accident.</p>
<p>This new set of classes is a new feature from dotnet core 2.1:</p>
<blockquote>
<p>The Generic Host is new in ASP<!-- raw HTML omitted --><!-- raw HTML omitted -->.NET Core 2.1 and isn&rsquo;t suitable for web hosting scenarios. For web hosting scenarios, use the Web Host. The Generic Host is under development to replace the Web Host in a future release and act as the primary host API in both HTTP and non-HTTP scenarios. - <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1">microsoft docs</a></p>
</blockquote>
<p>If you are used to the WebHostBuilder (<code>WebHost.CreateWebHostBuilder(args).Build().Run();</code>) then you will find the contracts for this very similar.  Let&rsquo;s look at an example of what a console app using this new library might look like.</p>
<p>Like last time, we will use this simple application that will sleep for 1 second, then try to generate the next number in the Fibonacci Sequence and print it out.</p>
<pre><code class="language-cs">using System;
using System.Threading;
using System.Threading.Tasks;

namespace MyApp
{
    public class MyApp
    {
        private static readonly AutoResetEvent _closeRequested = new AutoResetEvent(false);
        private long _last = 0;
        private long _current = 0;
        private Task _work;

        public MyApp()
        {
        }

        public void Start()
        {
            _work = Task.Run(() =&gt; DoWorkLoop());
        }

        public void Stop()
        {
            _closeRequested.Set();
            if (_work != null)
            {
                _work.Wait();
                _work = null;
            }
        }

        public void DoWorkLoop()
        {
            while (!_closeRequested.WaitOne(1000))
            {
                var last = _current;
                var next = _last + _current;
                if (next == 0)
                {
                    next = 1;
                }
                _last = _current;
                _current = next;
                Console.WriteLine(next);
            }
        }
    }
}
</code></pre>
<p>So how can we use this hosted in the new <code>HostBuilder</code>?</p>
<p>First, we have to use the new <code>IHostedService</code> interface:</p>
<pre><code>public interface IHostedService
{
    // Called when the host is ready to start the service
    Task StartAsync(CancellationToken cancellationToken);

    // Called on graceful shutdown by the host
    Task StopAsync(CancellationToken cancellationToken);
}
</code></pre>
<p>Notice the interface uses <code>CancellationToken</code>. This is called when the host needs to cancel the action (such as termination of the application during startup, or if you take too long during shutdown).</p>
<p>Our app class can be modified to meet these requirements:</p>
<pre><code class="language-cs">public class MyApp : IHostedService
{
    private static readonly AutoResetEvent _closeRequested = new AutoResetEvent(false);
    ...
    private Task _work;

    Task StartAsync(CancellationToken cancellationToken)
    {
        _work = Task.Run(() =&gt; DoWorkLoop());
        return Task.CompletedTask;
    }

    Task StopAsync(CancellationToken cancellationToken)
    {
        _closeRequested.Set();
        if (_work != null)
        {
            _task.Wait(cancellationToken);
            _work.Dispose();
            _work = null;
        }

        return Task.CompletedTask;
    }

    public void DoWorkLoop()
    {
        ...
    }
}
</code></pre>
<p>Now we meet the expected interface, we can build our startup code like so:</p>
<pre><code class="language-cs">public static class Program
{
    public static async Task Main(string[] args)
    {
        await new HostBuilder()
            .UseHostedService&lt;MyApp&gt;()
            .RunConsoleAsync();
    }
}
</code></pre>
<p>This is basically the minimum to get this working. But there is so much more you can do now you have a host builder.</p>
<p>Let&rsquo;s break this down into what those extensions are actually doing for you. The above is essentially equivalent to this:</p>
<pre><code class="language-cs">var host = new HostBuilder()
    .ConfigureServices(services =&gt;
        services.AddHostedService&lt;MyApp&gt;())
    .UseConsoleLifetime()
    .Build();

using (host)
{
    await host.StartAsync();

    await host.WaitForShutdownAsync();
}
</code></pre>
<p><code>UseConsoleLifetime</code>, which is used by <code>RunConsoleAsync()</code> internally, waits for Ctrl+C/SIGINT or SIGTERM commands from the OS (windows mac and Linux where applicable) to make the application compatible with graceful shutdown scenarios.</p>
<p><code>RunConsoleAsync()</code> also bootstraps the <code>Start</code> and <code>WaitForShutdown</code> usage, making it a really handy helper function to know and use.</p>
<p><code>ConfigureServices</code> is identical to that you are familiar with on the WebHostBuilder, and Startup classes.  This is your <code>ServiceCollection</code> where you can register dependencies. That&rsquo;s right, this has AspNetCore&rsquo;s Dependency Resolution structure.  <code>AddHostedService</code> is just a shorthand to register you class as an implementation of <code>IHostedService</code> that the Generic <em>Host</em> can later resolve to start and stop for you.</p>
<p>While talking about <code>AddHostedService</code>, I should mention you can have as many <code>IHostedService</code> instances registered that you want to have running. Multiple worker processes hosted in one app essentially.</p>
<p>Let&rsquo;s talk about configuration.</p>
<p>AspNetCore introduced the <code>IConfiguration</code> and the <code>appsettings.json</code> files.  I&rsquo;ve found that adding the following code gives you a very similar experience:</p>
<pre><code class="language-cs">new HostBuilder()
   .UseEnvironment(Environment.GetEnvironmentVariable(&quot;ASPNETCORE_ENVIRONMENT&quot;))
    .ConfigureAppConfiguration((hostContext, configApp) =&gt;
    {
        // ConfigureAppConfiguration makes sure the config is available
        // as runtime in the IConfiguration.
        // You can use ConfigureHostConfiguration which configures the
        // IHostingEnvironment's Build-type Configuration instead if you
        // care to make the distinction.
        // ConfigureAppConfiguration changes are also still visible on
        // IHostingEnvironment as well ¯\_(ツ)_/¯
        configApp
            .AddJsonFile(&quot;appsettings.json&quot;, optional: false, reloadOnChange: false)
            .AddJsonFile($&quot;appsettings.{hostContext.HostingEnvironment.EnvironmentName}.json&quot;, optional: true)
            .AddEnvironmentVariables()
            .AddCommandLine(args);
    })
    .ConfigureServices(services =&gt;
    {
        ...
        
        services.AddHostedService&lt;MyApp&gt;();
    }
    .Build();
</code></pre>
<p>This configuration should give you the appsettings loading, including the <code>Environment</code>-specific  config files using the same <code>ASPNETCORE_ENVIRONMENT</code> EnvironmentVariable you are used to (though you could call this whatever you want, really). It also loads EnvironmentVariables as config overrides, and enables command line argument overrides as well (as highest priority).</p>
<p>I will leave you with a mention of logging.</p>
<pre><code class="language-cs">.ConfigureLogging((hostcontext, loggingBuilder) =&gt;
{
    // I'm thinking you should go do your own reading on this one, I'm not going to give you ALL the code to copy-paste from!
    // https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1#configurelogging
    ...
})
</code></pre>
<p>Happy Coding!</p>
</description>
    </item>
    
    <item>
      <title>Retry Policies with Polly</title>
      <link>https://csmacnzblog.github.io/post/retry-policies-with-polly/</link>
      <pubDate>Mon, 13 Aug 2018 04:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/retry-policies-with-polly/</guid>
      <description><p>I originally set out to write about Polly. Then I started reading their documentation.  I quickly realised that I couldn&rsquo;t write anything as detailed and accurate as they already had available.  So instead, I&rsquo;m going to give more of a super high level, with links to relevant reading.</p>
<p>You can find their Documentation on their Github at <a href="https://github.com/App-vNext/Polly">github.com/App-vNext/Polly</a>, as well as plenty more resources at <a href="http://www.thepollyproject.org/">www.thepollyproject.org/</a>.</p>
<p>The elevator pitch is this:</p>
<blockquote>
<p>Polly is a .NET resilience and transient-fault-handling library that allows developers to express policies such as Retry, Circuit Breaker, Timeout, Bulkhead Isolation, and Fallback in a fluent and thread-safe manner.</p>
</blockquote>
<p>Basically, it handles the how of handling failure scenarios, so you can focus on the what. And they have enough guidance to help you with the what, too.</p>
<p>From version 6, Polly targets .Net Standard, and so runs anywhere you are compatible (so anywhere, really). This is split between targetting <code>NETSTANDARD1.1</code> for maximum compatibility, to a more modern <code>NETSTANDARD2.0</code>+ that has all the bells and whistles a modern standard allows. Both in one single shiny <code>nupkg</code>.</p>
<h3 id="why">Why</h3>
<p>The internet is flaky. There are layers upon layers of fault-tolerant protocols on top of faulty protocols. But the HTTP spec includes support for fault scenarios (Timeout, DNSResolveErrors, InternalServerError, TooManyRequests) and that puts the demand on us to handle these cases.</p>
<p>This has never been truer then it is hosting in the cloud. Providers guarantee that they will restart servers on you, recreate resources, migrate for Disaster Recovery (DR) failover automatically. Nothing is fixed, everything is fluid. Add on top of that your own deployment model to achieve blue-green deployment, zero-down-time etc etc. Flakiness is a when-not-if occurrence.</p>
<p>Handling these cases is always app-specific, but knowing what to handle and why isn&rsquo;t always clear or obvious. With Polly, and its supporting libraries as well as detailed guidance, you are already halfway there to provider better apps, and better service.</p>
<h3 id="standard-polly-cies">Standard Polly-cies</h3>
<p>There are several primary use cases where Polly is designed to help. I&rsquo;m going to list them in the order that I think (at least, <em>today</em> I think) should be considered and implemented.</p>
<h4 id="fallback">Fallback</h4>
<p>If anything goes wrong to the point of failure, you need to have a decision of what to do. If &ldquo;Crash the entire app&rdquo; or &ldquo;500 the HTTP request&rdquo; is a valid decision, you may start from there.</p>
<p>But more likely there will be an &ldquo;Unavailable&rdquo; message, a fallback image, a hard-coded result, an alternative display component, a too many requests Http Response. There will be something you can use in place of a hard failure. Thinking about, and determining this up front makes other decisions easier to make, especially around retries and timeouts.  You will hardly ever be writing business software where <code>UnhandledException</code> is a valid use case.</p>
<p>The Polly policy for fallback is documented <a href="https://github.com/App-vNext/Polly/wiki/Fallback">here</a>.</p>
<h4 id="timout">Timout</h4>
<p>You want to be fast. You want to be responsive. You don&rsquo;t want to wait forever. There is probably a point that if you haven&rsquo;t got an answer yet, waiting another 5 minutes probably won&rsquo;t help.  Work out what you can tolerate, what is a reasonable time for a response, and configure a proper timeout.</p>
<p>You can do a lot with Polly here. It could be GETs and POSTs have different timeouts. It could be lower for auxiliary data, and higher for primary data sources. Polly is pretty flexible if you need to get really custom. But think about timeouts early and monitor your dependencies for adjustment as necessary.</p>
<p>Revisit your fallback, and see if it makes sense on timeout, and if not, either alter it or create an alternative fallback for timeouts.</p>
<p>The Polly policy for timeout is documented <a href="https://github.com/App-vNext/Polly/wiki/Timeout">here</a>.</p>
<h4 id="retry">Retry</h4>
<p>Retry doesn&rsquo;t mean you will eventually get an answer, but it does mean if you wait, you might do.  If we already handle Fallback and Timeout, we can be confident in what happens when our final retry fails.</p>
<p>We know some errors are transient, and if we try again it might actually work the next time. So we use a retry policy to try again. We want to have some sort of delay, and we want to think about using a back-off strategy, too. We don&rsquo;t want to be the cause of a DDOS or making any service exhaustion issues worse.</p>
<p>This is probably the most discussed of all the error-handling strategies so I will defer to others, and point you at the Polly retry documentation <a href="https://github.com/App-vNext/Polly/wiki/Retry">here</a>.</p>
<h4 id="circuit-breaker">Circuit Breaker</h4>
<p>I briefly mentioned back-off and service exhaustion in the Retry section. CircuitBreaker is another approach that helps here.</p>
<p>The most common analogy is the fuse box in your house. If an appliance is faulty, it blows the fuse and breaks the circuit. This stops the bad electricity problem from continuing.  When you have isolated the problem, you can reset the fuse, and try again. If you haven&rsquo;t isolated the problem, the fuse will break the circuit again, until it is made right again.</p>
<p>This is a basic circuit breaker pattern, and you can imagine how this applies to software, service failures or outages.</p>
<p>The Polly Circuit Breaker allows you to &ldquo;blow the fuse&rdquo; after a bunch of failures, assuming the remote service has issues. This broken fuse stops other parts of the application making the same request, they hit the same broken circuit and fail fast. The main benefits from a circuit breaker pattern are that your application can return a failure without even attempting to make the call, which makes the application fast, and also avoids contributing to exhaustion issues.</p>
<p>Polly Circuit Breaker docs are <a href="https://github.com/App-vNext/Polly/wiki/Circuit-Breaker">here</a>.</p>
<h4 id="bulkhead">Bulkhead</h4>
<p>Their description of the Bulkhead pattern is much better than I could come up with:</p>
<blockquote>
<p>A bulkhead is a wall within a ship which separates one compartment from another, such that damage to one compartment does not cause the whole ship to sink.</p>
<p>Similarly, a bulkhead isolation policy assigns operations to constrained resource pools, such that one faulting channel of actions cannot swamp all resource (threads/CPU/whatever) in a system, bringing down other operations with it. The impact of a faulting system is isolated to the resource-pool to which it is limited; other threads/pools/capacity remain to continue serving other calls.</p>
</blockquote>
<p>We basically limit the number of requests to a particular resource, so that if too many requests are issued, further requests are turned away fast to avoid resource exhaustion. Again, when this happens we need to consider our retries, circuit breakers, and fallbacks for how our application behaves and responds to this exhaustion (<a href="https://httpstatuses.com/429">429?</a>).</p>
<p>Polly talks about this more <a href="https://github.com/App-vNext/Polly/wiki/Bulkhead">here</a>.</p>
<h4 id="combinationspipeline">Combinations/Pipeline</h4>
<p>You can chain these policies together, too. For instance, you may chain a Retry, to a CircuitBreaker to a Timeout. This means a request will go into Retry, then CircuitBreaker, then Timeout. Each request will be limited to a short timeout. That then updates the state of the circuit and then hits Retry. Our Retry might wait a short space of time (ms) and try again. That might be enough and a timeout might not be hit this time. If the Timeout fails again, we may trigger our CircuitBreaker. Our Retry triggers again and we wait longer. If we haven&rsquo;t waited long enough we hit the CircuitBreaker and fail onto another retry. If we wait on Retry again, the circuit will be restored. and we try again and hopefully get past the timeout this time.  Too many trys and we give up and call it a failure. We may now resort to showing our fallback here, perhaps.</p>
<p>A much better explanation of this (with diagrams) is <a href="https://github.com/App-vNext/Polly/wiki/Polly-and-HttpClientFactory#applying-multiple-policies">here</a>, as well as example codes of how this hooks together.</p>
<h3 id="net-core-21">.Net Core 2.1</h3>
<p>If you&rsquo;ve been following the .Net 2.1 <code>IHttpClientFactory</code> changes, you will be happy to hear that Polly has this usage in mind already.</p>
<p>A large part of this boils down to avoiding some of the pitfalls associated with managing HttpClient yourself (<a href="https://aspnetmonsters.com/2016/08/2016-08-27-httpclientwrong/">the disposing-it-too-often-can-cause-socket-exhaustion</a> but also <a href="http://byterot.blogspot.co.uk/2016/07/singleton-httpclient-dns.html">only-using-a-singleton-can-miss-DNS-updates</a> aspects). (Text as taken from the Polly docs.)</p>
<p>You can see their documentation <a href="https://github.com/App-vNext/Polly/wiki/Polly-and-HttpClientFactory">Polly and HttpClientFactory</a> as well as mention of Polly specifically on the official <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.1">Initiate HTTP requests</a> page (about <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.1#use-polly-based-handlers">three-quarters of the way down</a>).</p>
<p>Plugging in Polly Policies at the <code>HttpMessageHandler</code> level can keep your calling code just the way you are used to while providing the benefits of these Policies. It could also mean you can provide policies for third-party libraries that expose the HttpClient enough to inject your own Polly Message Handlers.</p>
<h3 id="roadmap">Roadmap</h3>
<p>Polly even has a <a href="https://github.com/App-vNext/Polly/wiki/Polly-Roadmap">roadmap</a> set out so you can see what is being worked on for future releases.</p>
<p>Like I said, the docs are thorough, so refer to them as you start building out with Polly and make your applications more robust, and more useful when (not if) things go wrong.</p>
</description>
    </item>
    
    <item>
      <title>.Net on Docker - What&#39;s in my Dockerfile? Tips and Tricks</title>
      <link>https://csmacnzblog.github.io/post/dotnet-docker-tips-and-tricks/</link>
      <pubDate>Mon, 16 Jul 2018 06:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/dotnet-docker-tips-and-tricks/</guid>
      <description><p>I&rsquo;ve started getting into building Docker Containers as deployment packages.  These are some learnings that I want to share, hopefully helping countless others with a better build, test and debug cycle with .Net on Docker with Visual Studio.</p>
<h3 id="start-with-the-defaults">Start with the defaults</h3>
<p>Use the built-in tools in Visual Studio to docker-ify and docker-compose your projects. The defaults all work, and provide a nice reference implementation of how to do things.</p>
<p>In Visual Studio 2017 (I&rsquo;m using 15.7.3, so at least that version if not earlier) You can select a project from the Solution Explorer, <code>right-click =&gt; Add</code> and you will see options for <code>Docker Support</code> and <code>Container Orchestrator Support</code>.</p>
<p><img src="http://res.cloudinary.com/csmacnz/image/upload/c_scale,w_387/v1531727131/DockerSupport_l16dry.png" alt="Visual Studio Project context menu showing Docker commands."></p>
<p>Docker Support will create a <code>Dockerfile</code> for your project, that follows some conventions and best practices, including separate <code>build</code>/<code>publish</code> steps. (This may be limited to <code>NetCoreApp</code> projects, I haven&rsquo;t thoroughly tested this function yet outside if that scope. You can even choose between Windows and Linux Containers. This might also create the docker-compose, and <code>.dockerignore</code> files as well.</p>
<p>Container Orchestrator Support creates a new <code>*.dcproj</code> project in your solution that orchestrates a docker-compose file which includes your selected project. If you already have an orchestrator project, the selected project will be added to it.</p>
<p>You can also find <a href="https://docs.docker.com/engine/examples/dotnetcore/">instructions on docs.docker.com for .Net Core apps</a> which covers some of the basics and recommendations too.</p>
<h3 id="proximity-is-key">Proximity is key</h3>
<p>Put your <code>Dockerfile</code> in the same folder as the csproj file. At some point in the future (or if someone really digs into the MSBuild files and finds a hack) this should be able to go anywhere. But for now, putting it at the root of the project with the <code>*.csproj</code> project file lets it work correctly with Visual Studio.</p>
<p>By default, you also usually have everything relative to a parent directory, such as the source or repository root. This becomes the context you use.  The context can be anywhere you like, but I find shared configs from root as well as the solution file being available is handy. You may even have build scripts here that you include.</p>
<h3 id="minimum-vs-default">Minimum vs default</h3>
<p>Let&rsquo;s start with the minimum valid <code>Dockerfile</code> to build our NetCoreApp2.1 application. The application itself doesn&rsquo;t matter, only that it builds.</p>
<pre><code>FROM microsoft/dotnet:2.1-sdk
WORKDIR /src
COPY . .
RUN dotnet publish MyApp.csproj -c Release -o /app
WORKDIR /app
COPY /app .
ENTRYPOINT [&quot;dotnet&quot;, &quot;MyApp.dll&quot;]
</code></pre>
<p>That&rsquo;s the least you need, but we can do better.</p>
<ul>
<li>This only works if you run build in the context of the project folder</li>
<li>This will copy over local bin/obj folders (unless you have a <code>.dockerignore</code> file already - Visual Studio may add one for you.)</li>
<li>Our final container is large because it includes all of the dotnet CLI build tools</li>
<li>Our final container has all the build artifacts in it, making it larger again</li>
</ul>
<p>Most of this is solved by following the <a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">Best practices</a> which you get for free if you create using Visual Studio.</p>
<pre><code>FROM microsoft/dotnet:2.1-runtime AS base
WORKDIR /app

FROM microsoft/dotnet:2.1-sdk AS build
WORKDIR /src
COPY MyApp/MyApp.csproj MyApp/
RUN dotnet restore MyApp/MyApp.csproj
COPY . .
WORKDIR /src/MyApp
RUN dotnet build MyApp.csproj -c Release -o /app

FROM build AS publish
RUN dotnet publish MyApp.csproj -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT [&quot;dotnet&quot;, &quot;MyApp.dll&quot;]

</code></pre>
<h3 id="multiple-stages">Multiple Stages</h3>
<p>Talking through this file a bit, we have a multi-stage build, that has three parts.
Note that the actual container instance that matches the tag, is the one that starts with the base container defined in the <code>FROM</code> command, and has run all the instructions up until the next <code>FROM</code> command, or the end of the file.</p>
<p>First, we have a <code>base </code>(<code>FROM microsoft/dotnet:2.1-runtime AS base</code>) that serves two purposes: it defines the final result container base up front and also gets used by Visual Studio when performing a special debug build. Visual Studio will build just this target in a multi-stage build, and copy in the build results to debug with. We can declare anything here that we might want in our final output container, and also need during debugging.</p>
<p>Next, we have a <code>build</code> (<code>FROM microsoft/dotnet:2.1-sdk AS build</code>) which is the container the app is built in. This is where we copy over all our source files (<code>COPY . .</code>).</p>
<p>Next, a <code>publish</code>(<code>FROM build AS publish</code>) which starts from our earlier <code>build</code>, and is used to produce the final binaries.</p>
<p>And finally, a <code>final</code> (<code>FROM base AS final</code>) that starts with our <code>base</code> from earlier and produces the container we consider the resulting application. This container is also configured with any ports we want to expose (possibly done in <code>base</code>) and our application entry point (<code>ENTRYPOINT [&quot;dotnet&quot;, &quot;/app/GitHubTagAndRelease.dll&quot;]</code>).</p>
<p>Using multistage in this way solves the large container size concerns from earlier, and even if we copy too much</p>
<p>Briefly about caching. Each build step will cache the results if all previous steps are cached, and with <code>COPY</code> commands, if the hash of the source files hasn&rsquo;t changed.  For this reason, we selectively copy over the project first, run a <code>dotnet restore</code>, and then pull in everything else. This caches the NuGet restore step so we don&rsquo;t have to redownload these every time.</p>
<h3 id="ignore">Ignore</h3>
<p>We still have the issue of the bin/obj files being copied in from the source folder. Luckily, Visual Studio would add a <code>.gitignore</code> file to solve this. If you add your own, the ignore lines you want are:</p>
<pre><code>*/bin
*/obj
</code></pre>
<p>This is relative to the base path, so will match <code>MyApp/bin</code> and <code>MyApp.Tests/bin</code> but not <code>src/MyOtherProject/bin</code>. If you want a more comprehensive version, VS gives you this:</p>
<pre><code>.dockerignore
.env
.git
.gitignore
.vs
.vscode
docker-compose.yml
docker-compose.*.yml
*/bin
*/obj
</code></pre>
<p>Note that we don&rsquo;t ignore the <code>Dockerfile</code>, which means changes to the <code>Dockerfile</code> also cache-bust at the <code>COPY</code> step.</p>
<h3 id="build-with-testing-in-mind">Build with testing in mind</h3>
<p>Like the default conventions, I build in a <code>build</code> container, then publish to a <code>publish</code> container. This means the final container has minimal dependencies. But I add a twist.</p>
<p>When the script does the <code>COPY</code> of the project before the restore (a nice caching enhancement I really like) I also copy the test project file at the same time. This gets restored with the project in another restore. Then after doing the project build, I also run the project Tests. Now I know that my container passed all tests before it built because it has to.</p>
<pre><code>ARG DOCKER_SKIP_TESTS=

FROM microsoft/dotnet:2.1-runtime AS base
WORKDIR /app

FROM microsoft/dotnet:2.1-sdk AS build
WORKDIR /src
COPY MyApp/MyApp.csproj MyApp/
COPY MyApp.Tests/MyApp.Tests.csproj MyApp.Tests/
RUN dotnet restore ./MyApp/MyApp.csproj /p:Configuration=Release
RUN dotnet restore ./MyApp.Tests/MyApp.Tests.csproj /p:Configuration=Release
COPY . .
RUN dotnet build ./MyApp/MyApp.csproj --no-restore -c Release -o /app

FROM build as test
ARG DOCKER_SKIP_TESTS

WORKDIR /src
RUN [ ! -z &quot;$DOCKER_SKIP_TESTS&quot; ] &amp;&amp; : || dotnet build ./MyApp.Tests/MyApp.Tests.csproj --no-restore -c Release
RUN [ ! -z &quot;$DOCKER_SKIP_TESTS&quot; ] &amp;&amp; : || dotnet test ./MyApp.Tests/MyApp.Tests.csproj --no-restore --no-build -v normal -c Release

FROM build AS publish
WORKDIR /src/MyApp
RUN dotnet publish MyApp.csproj -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT [&quot;dotnet&quot;, &quot;MyApp.dll&quot;]

</code></pre>
<p>When running build and release against the target project, I also tell it to skip the restore. This avoids any restore invalidation that may occur from doing the <code>COPY</code>, for whatever reason.  Also during the release, I skip the build, so it reuses the build result from the previous step. Splitting up these steps just saves that little bit of rebuild time and duplication along the way.</p>
<p>I use bash conditional logic to be able to disable the tests from running (to go faster during dev build cycles) as well. The build-arg <code>DOCKER_SKIP_TESTS</code> is unset, and the test commands are run. If I declare this, it will skip running the tests.</p>
<pre><code>docker build --build-arg DOCKER_SKIP_TESTS=1 -f .\MyApp\Dockerfile .
</code></pre>
<p>Having <code>DOCKER_SKIP_TESTS=</code> declared on the first line means the cache is invalidated whenever I switch this setting on and off, so I get a clean build with, or without tests, and not somewhere in between.</p>
<p>I&rsquo;ve even managed to convince my <code>Dockerfile</code> it is a ci agent, and it publishes coverage and test results to TeamCity&hellip; but that is for another article I think.</p>
<h3 id="wrap-up">Wrap up</h3>
<p>These are some of the tricks that I make use of in my <code>Dockerfile</code>.  Next time, we will take a look at some more advanced features, using an AspNetCore application running in docker and Visual Studio debugging.</p>
<p>For an example of this working in practice, I&rsquo;ve set up an example project on GitHub. <a href="https://github.com/csMACnzBlog/DockerDotnetDemo">github.com/csMACnzBlog/DockerDotnetDemo</a></p>
</description>
    </item>
    
    <item>
      <title>More .Net on Docker - AspNet Core Debugging Tips and Tricks</title>
      <link>https://csmacnzblog.github.io/post/dotnet-docker-aspnetcore-tips-and-tricks/</link>
      <pubDate>Sun, 15 Jul 2018 22:02:30 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/dotnet-docker-aspnetcore-tips-and-tricks/</guid>
      <description><p><a href="/dotnet-docker-tips-and-tricks/">Last time</a> we covered some basics of <code>Dockerfile</code> with a console application. Let&rsquo;s continue our journal with AspNet Core.</p>
<h3 id="develop-time-dependencies">Develop-time dependencies</h3>
<p>We are using React and the .Net WebPack Hot Reloader. While at development time this requires node, at runtime it doesn&rsquo;t.  Here is a couple of fun facts about Visual Studio debugging I combine in an interesting way.</p>
<p>Visual Studio Run (F5) on a docker-compose builds locally. This means it doesn&rsquo;t actually use or do what your <code>Dockerfile</code> says. Instead, it takes the first (and only first) defined named USE from your <code>Dockerfile</code>, and builds that.</p>
<p>Fact number 2, Once built, it will launch an instance, and attach (volume mount) the application and run it.</p>
<p>Fact number 3 is docker-compose.yml.  Your docker-compose project uses several docker-compose files stacked together. First, your <code>docker-compose.yml</code> file, then if you have one, the <code>docker-compose.override.yml</code> file. This is followed by some generated ones by visual studio, that will override most of the details if it detects the referenced <code>Dockerfile</code> has a <code>*.csproj</code> beside it.  You can then create a <code>docker-compose.vs.debug.yml</code> or <code>docker-compose.vs.release.yml</code> (depending on <code>debug</code> or <code>release</code> build selection) that will allow you to override anything extra you want on for debugging.  This lets you set environment variables for your container to use (such as <code>ASPNETCORE_ENVIRONMENT</code> to Development) if different from the default or override you use.</p>
<p>Putting this all together: In my <code>Dockerfile</code>, I make sure the first <code>USE</code> sets up a docker image that has the node runtime dependencies to make the Hot Reloading work. And because the source is a Volume Mount, local changes reflect inside the container, too. My build and publish <code>USE</code> containers in my multi-stage build don&rsquo;t depend on this debug one, and instead the debug container is thrown away, except when used during debugging in Visual Studio.</p>
<p>I then make sure the <code>docker-compose.yml</code> is going to use a non-Development build by default. This should build as a <code>Production</code> Environment instead. The <code>docker-compose.debug.yml</code> sets back to <code>Development</code> during debug. I configure my Hot Reloading to only configure and run when <code>IsDevelopment()</code> is true.</p>
<p>Now when I debug Run the docker-compose project, my application is attached to the debugger, with node available in the container, in DevelopmentMode using Hot Reloading of my React app.</p>
<p>When I build the real docker container, the publish result has no node installed, saving me a few <code>Mbs</code>, and one less moving part it doesn&rsquo;t need. (If you tried to use it in Debug mode, it would even crash because node is missing, a bonus as-designed feature.)</p>
</description>
    </item>
    
    <item>
      <title>Clean Startup in your AspNetCore</title>
      <link>https://csmacnzblog.github.io/post/clean-startup-in-your-aspnetcore/</link>
      <pubDate>Mon, 02 Jul 2018 06:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/clean-startup-in-your-aspnetcore/</guid>
      <description><p>I want to talk about this point made about <a href="https://odetocode.com/blogs/scott/archive/2016/08/30/keeping-a-clean-startup-cs-in-asp-net-core.aspx">Keeping a Clean Startup.cs in Asp.Net Core</a> by K. Scott Alan. Mostly I want to agree and elaborate on it.</p>
<p>(Warning! I used the British English <code>customised</code> below. If this <a href="http://grammarist.com/spelling/customise-customize/">doesn&rsquo;t match your sensibilities</a>, just use <code>customize</code> instead.)</p>
<h3 id="the-idea">The Idea</h3>
<p>The basic idea is that we have a <code>Startup.cs</code> file, where we configure our application. This becomes a dumping ground for all sorts of configuration of both services, and pipeline if we let it.  This is a simple pattern to avoid the mess and organise your code.</p>
<p>It is a simple &lsquo;what&rsquo; vs &lsquo;how&rsquo; situation.  In your <code>Startup.cs</code> you want to see the &lsquo;what&rsquo;. The &lsquo;how&rsquo; should be abstracted away to go look at separately.</p>
<p>The simple example given in the original example by OdeToCode is the final code that looks like this:</p>
<pre><code>public void ConfigureServices(IServiceCollection services)
{
    // ...
    services.AddCustomizedMvc();
    services.AddCustomizedIdentity();
    services.AddDataStores();
    // ...
}
</code></pre>
<h3 id="unpacking-the-idea">Unpacking the idea</h3>
<p>I have a few specific implementation details I have taken away from this.</p>
<h4 id="naming">Naming</h4>
<p>The first is a naming convention.  We already have extension methods for <code>IApplicationBuilder</code> in <code>Configure</code> and <code>IServiceCollection</code> in <code>ConfigureServices</code>. These follow a convention of <code>AddX</code> and <code>UseX</code> and are pipelines that take and return the Builder/Services.  If you are building extensions in a library, this convention should be followed for these.</p>
<p>If you are creating these application-specific Extensions, the naming convention <code>UseCustomisedX</code> and <code>AddCustomisedX</code> works well, both showing their intent while distinguishing local vs library items.</p>
<pre><code>public static IServiceCollection AddCustomisedMvc(this IServiceCollection services)
{
    // ...
    return services;
}

public static IApplicationBuilder UseCustomisedMvc(this IApplicationBuilder app)
{
    // ...
    return app;
}
</code></pre>
<h4 id="cohesion">Cohesion</h4>
<p>Most, but not all, components added to Startup have both an <code>Add</code> and a <code>Use</code>. That is, you register services, and you add to the pipeline. Now that we pull the &lsquo;how&rsquo; of these out into extensions methods, we can group them together in the same file. It just makes sense.  So if we have our MVC customisations, we create a <code>MvcExtensions</code> class.</p>
<pre><code>public static class MvcExtensions
{
    public static IServiceCollection AddCustomisedMvc(this IServiceCollection services)
    {
        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);

        return services;
    }

    public static IApplicationBuilder UseCustomisedMvc(this IApplicationBuilder app)
    {
        app.UseMvc(routes =&gt;
        {
            routes.MapRoute(
                name: &quot;default&quot;,
                template: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
        });

        return app;
    }
}
</code></pre>
<h4 id="namespacing">Namespacing</h4>
<p>I would love to put these Extensions in a folder called Startup. But it is bad practice to have a Class and Namespace called the same thing. So instead I use <code>StartupExtensions</code> as the namespace/folder. inside are all the <code>XExtensions</code> classes that our system is using.</p>
<h4 id="pass-through-dependencies">Pass through dependencies</h4>
<p>You may find that your extension needs <code>IConfiguration</code> or <code>IHostingEnvironment</code>. That is fine. You can pass these into the method as necessary in the normal way.</p>
<h4 id="piping">Piping</h4>
<p>If you correctly build your customised methods as both Extension Methods, and as pipes, you can keep the code even cleaner. You could use the lambda syntax to create a functional version of each method like this:</p>
<pre><code>
public void ConfigureServices(IServiceCollection services) =&gt; services
    .AddCustomisedCookies()
    .AddCustomisedMvc();

public void Configure(IApplicationBuilder app, IHostingEnvironment env) =&gt; app
    .UseCustomisedErrorHandling(env)
    .UseHttpsRedirection()
    .UseStaticFiles()
    .UseCustomisedMvc();
</code></pre>
<h3 id="conditional-flow">Conditional Flow</h3>
<p>You may have conditional flow in your middleware pipeline. I have two different options, you can pick the right one for the right situation.</p>
<h4 id="put-it-in-the-extensions">Put it in the Extensions</h4>
<p>If the logic fits nicely into one particular aspect of your setup (such as Error Handling and Development mode) you can just keep the conditions you need but inside that extension.</p>
<pre><code>public static IApplicationBuilder UseCustomisedErrorHandling(this IApplicationBuilder app, IHostingEnvironment env)
{
    if (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    else
    {
        app.UseExceptionHandler(&quot;/Home/Error&quot;);
    }

    return app;
}
</code></pre>
<h4 id="branching-middleware">Branching middleware</h4>
<p>If your middleware has complex pipeline branching, you probably should consider that more of a <code>what</code> than a <code>how</code>.  I would recommend keeping this in the Startup, still. An example of this might be:</p>
<pre><code>app.UseCustomisedErrorHandling();
app.MapWhen(
    ctx =&gt; IsAdminArea(ctx.Request.Path),
    builder =&gt;
    {
        builder.UseCustomisedAuthorisation();
        builder.UseCustomisedMvc();
    });
app.UseCustomisedMvc();
</code></pre>
<p>What you can see here at a high level is &lsquo;what&rsquo; is configured for each of the branches, while still abstracting away the &lsquo;how&rsquo;.</p>
<p>However, if you have a more aspect-specific <code>MapWhen</code>, (such as &ldquo;When the URL is <code>/ping</code> return a 200&rdquo;) this can probably still be pulled out into an Extension. The above only really applies when you have branched complex middleware pipelines.</p>
<h3 id="sample">Sample</h3>
<p>I ran a <code>dotnet new mvc</code> to produce a new project. I created a before and after version and you can see an example of the refactoring following the above rules. This can be found at <a href="https://github.com/csMacnzBlog/CleanStartup">github.com/csMacnzBlog/CleanStartup</a>. There is also a <a href="https://github.com/csMacnzBlog/CleanStartup/blob/FullPipeline/after/Startup.cs">Full Pipeline branched version</a> available.</p>
</description>
    </item>
    
    <item>
      <title>A Windows Service using netcoreapp on dotnet</title>
      <link>https://csmacnzblog.github.io/post/a-windows-service-on-dotnet/</link>
      <pubDate>Sun, 22 Apr 2018 07:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/a-windows-service-on-dotnet/</guid>
      <description><p>I wrote <a href="/building-a-windows-service-with-net-core/">Building a Windows Service with .Net Core</a> and had a bit of flack because I was only using .Net core to build a .Net 4.5.2 application.  Technically the title is still valid, it was a windows service, and I built it using .Net Core tools.  But since people came looking for the answer to actually hosting a NetCoreApp application as a Windows Service, I thought it best to follow up with that article as well.</p>
<p>Note that since windows Service logic and hooks are Windows-specific, this solution doesn&rsquo;t work for Mac or Linux.  However I will try to maintain a working Console application, that should satisfy the requirements there.</p>
<h2 id="just-target-net-full-framework">Just target .Net Full framework</h2>
<p>Everything you already have working in your services using <code>System.ServiceProcess.ServiceBase</code> and other classes from the <code>System.ServiceProcess</code> full framework assemblies work fine when compiled with .Net Core. Since you can&rsquo;t run a Windows Service on non-windows platforms, there is no reason not to just target the Windows-only full framework 4.6.2 or 4.7.1 or whichever your stable .Net version of choice is. None of the <code>System.ServiceProcess</code> code can run on Linux or Mac anyway, and neither can any Windows Service specific code. This is probably going to be the path of least resistance.</p>
<p>But that was the subject of the <a href="/building-a-windows-service-with-net-core/">other article</a>, I assume you are here for something different.</p>
<h2 id="cross-platform-solution">Cross Platform solution</h2>
<p>We will now take a look at what we can do to make an application that a) can install and run as a windows service, and b) still runs as a console app on Linux, ignoring the unused service code.  This application is going to be a portable <code>netcoreapp2.0</code> application, so we can only reference <code>netstandard</code> or <code>netcoreapp</code> libraries.</p>
<p><a href="https://github.com/dasMulli/dotnet-win32-service">dasMulli/dotnet-win32-service</a> is a project that has created a win32 interop layer over the Windows Service API.  Much like the way the original .Net code probably works, but compiled as a dotnet standard library (<code>netstandard1.3</code> and <code>netstandard2.0</code> compatible versions).  On top of this, there is another library <a href="https://github.com/PeterKottas/DotNetCore.WindowsService">PeterKottas/DotNetCore.WindowsService</a> which also targets <code>netstandard2.0</code> that we will use to give us a nicer install/uninstall interface into our application.</p>
<h3 id="the-application">The &lsquo;Application&rsquo;</h3>
<p>Let&rsquo;s use something pretty dumb. Our app will sleep for 1 second, Then try to generate the next number in the Fibonacci Sequence.</p>
<pre><code class="language-cs">using System;
using System.Threading;
using System.Threading.Tasks;

namespace MyApp
{
    public class MyApp
    {
        private static readonly AutoResetEvent _closeRequested = new AutoResetEvent(false);
        private long _last = 0;
        private long _current = 0;
        private Task _work;

        public MyApp()
        {
        }

        public void Start()
        {
            _work = Task.Run(() =&gt; DoWorkLoop());
        }

        public void Stop()
        {
            _closeRequested.Set();
            if (_work != null)
            {
                _work.Wait();
                _work = null;
            }
        }

        public void DoWorkLoop()
        {
            while (!_closeRequested.WaitOne(1000))
            {
                var last = _current;
                var next = _last + _current;
                if (next == 0)
                {
                    next = 1;
                }
                _last = _current;
                _current = next;
                Console.WriteLine(next);
            }
        }
    }
}
</code></pre>
<p>I&rsquo;ve added some boiler-plate start/stop logic including a mutex to release the app and wait for it to finish in the stop command.</p>
<p>To run as a console app, I could simply wait for a keypress:</p>
<pre><code class="language-cs">var app = new MyApp();
app.Start();
Console.ReadKey();
Console.WriteLine(&quot;Stopping&quot;);
app.Stop();
</code></pre>
<p>or I could make use of requiring ctrl+c to exit instead:</p>
<pre><code class="language-cs">private static readonly AutoResetEvent _closing = new AutoResetEvent(false);

static void Main(string[] args)
{
    Console.WriteLine(&quot;Hello World!&quot;);
    var app = new MyApp();
    app.Start();
    Console.CancelKeyPress += new ConsoleCancelEventHandler(OnExit);
    _closing.WaitOne();
    Console.WriteLine(&quot;Stopping&quot;);
    app.Stop();
}

protected static void OnExit(object sender, ConsoleCancelEventArgs args)
{
    Console.WriteLine(&quot;Exit Requested&quot;);
    _closing.Set();
    args.Cancel = true;
    Console.CancelKeyPress -= new ConsoleCancelEventHandler(OnExit);
}
</code></pre>
<p>Either way, we now have a functioning console app, in a format that is compatible with a Windows Service.</p>
<h3 id="install-the-libraries">Install the libraries</h3>
<p>As mentioned, we will use <a href="https://github.com/PeterKottas/DotNetCore.WindowsService">PeterKottas/DotNetCore.WindowsService</a> nuget package <a href="https://www.nuget.org/packages/PeterKottas.DotNetCore.WindowsService/">PeterKottas.DotNetCore.WindowsService</a> to make our life easier. (<code>dotnet add package PeterKottas.DotNetCore.WindowsService</code>)</p>
<h3 id="the-program">The Program</h3>
<p>Now we can change our program to start using the code from the library, instead of our code:</p>
<pre><code class="language-cs">using System;
using System.Threading;
using PeterKottas.DotNetCore.WindowsService;

namespace MyApp
{
    public class Program
    {
        static void Main(string[] args)
        {
            ServiceRunner&lt;MyApp&gt;.Run(config =&gt;
            {
                var name = config.GetDefaultName();
                config.SetName(&quot;MyAppService&quot;);
                config.SetDescription(&quot;An example application&quot;);
                config.SetDisplayName(&quot;MyApp As A Service&quot;);
                config.Service(serviceConfig =&gt;
                {
                    serviceConfig.ServiceFactory((extraArguments, serviceController) =&gt;
                    {
                        return new MyApp();
                    });
                    serviceConfig.OnStart((service, extraArguments) =&gt;
                    {
                        Console.WriteLine(&quot;Service {0} started&quot;, name);
                        service.Start();
                    });

                    serviceConfig.OnStop(service =&gt;
                    {
                        Console.WriteLine(&quot;Service {0} stopped&quot;, name);
                        service.Stop();
                    });

                    serviceConfig.OnInstall(service =&gt;
                    {
                        Console.WriteLine(&quot;Service {0} installed&quot;, name);
                    });

                    serviceConfig.OnUnInstall(service =&gt;
                    {
                        Console.WriteLine(&quot;Service {0} uninstalled&quot;, name);
                    });

                    serviceConfig.OnPause(service =&gt;
                    {
                        Console.WriteLine(&quot;Service {0} paused&quot;, name);
                    });

                    serviceConfig.OnContinue(service =&gt;
                    {
                        Console.WriteLine(&quot;Service {0} continued&quot;, name);
                    });

                    serviceConfig.OnError(e =&gt;
                    {
                        Console.WriteLine(&quot;Service {0} errored with exception : {1}&quot;, name, e.Message);
                    });
                });
            });
        }
    }
}
</code></pre>
<p>I also had to add the <code>IMicroService</code> interface to <code>MyApp</code>, but otherwise it stayed the same since I already implemented the <code>Start</code>/<code>Stop</code> methods. Yes, it is a tonne more code, but thats just me logging state transitions, your app may not want or need to implement every event handler.</p>
<p>Now the app runs two ways:</p>
<pre><code class="language-powershell">dotnet run
</code></pre>
<pre><code class="language-shell">Starting up as a console service host
Service MyApp.MyApp started
The MyAppService service is now running, press Control+C to exit.
1
1
2
3
5
8
13
21
Control+C detected, attempting to stop service.
Service MyApp.MyApp stopped
The MyAppService service has stopped.
</code></pre>
<p>And also installed as a service:</p>
<pre><code class="language-powershell">dotnet run action:install
</code></pre>
<pre><code class="language-shell">Successfully registered and started service &quot;MyAppService&quot; (&quot;An example application&quot;)
</code></pre>
<p><img src="http://res.cloudinary.com/csmacnz/image/upload/v1523006256/MyAppService_rtae5s.png" alt="MyApp running as a Service"></p>
<h3 id="on-linux">On Linux</h3>
<p>In theory, we can take this app as written and build and run it as a console app on Linux.  This is because all our code is portable dotnet core <code>netstandard</code> and <code>netcoreapp</code> cross-platform code.  Yes, we have some interop code that expects some windows APIs, but in theory, if we never execute that code, it won&rsquo;t cause any issues.  Let&rsquo;s find out.</p>
<p>The easiest way to run Linux on windows is probably docker, so we can test using that.
(This assumes you have Docker installed and set up, otherwise, just follow along on any Linux environment you have.)</p>
<p>I am going to run the <code>Microsoft/aspnetcore-build</code> image, so that the tools are available, and map the dev folder I was already using. I will just start a <code>bash</code> shell so that I basically simulate working on my folder from a Linux machine. (Your networking may vary.)</p>
<pre><code class="language-powershell"> docker run --rm -it -v &quot;$(pwd):/app&quot; -w /app microsoft/aspnetcore-build bash
</code></pre>
<p>This will likely spend some time pulling down the image if you haven&rsquo;t used it before. Once that is done you will be dropped into a bash shell inside an instance of a <code>Microsoft/aspnetcore-build</code> Linux container with the windows folder directory containing out application mapped to the <code>/app</code> folder.</p>
<p>(As mentioned, if you don&rsquo;t have docker, or would rather use a Linux environment you already have, the rest of the instructions should work much the same.)</p>
<p>All you need to do is build and run, and you should get a working application.</p>
<pre><code class="language-shell">root@2683f31d537c:/app# ls
MyApp.cs  MyApp.csproj  Program.cs  bin  obj
root@2683f31d537c:/app# dotnet build
Microsoft (R) Build Engine version 15.6.84.34536 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restoring packages for /app/MyApp.csproj...
  Installing System.ServiceProcess.ServiceController 4.4.0.
  Installing DasMulli.Win32.ServiceUtils 1.0.1.
  Installing PeterKottas.DotNetCore.CmdArgParser 1.0.5.
  Installing PeterKottas.DotNetCore.WindowsService 2.0.6.
  Generating MSBuild file /app/obj/MyApp.csproj.nuget.g.props.
  Generating MSBuild file /app/obj/MyApp.csproj.nuget.g.targets.
  Restore completed in 3.08 sec for /app/MyApp.csproj.
  MyApp -&gt; /app/bin/Debug/netcoreapp2.0/MyApp.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:06.79
root@2683f31d537c:/app# dotnet run
Starting up as a console service host
Service MyApp.MyApp started
The MyAppService service is now running, press Control+C to exit.
1
1
2
3
5
^CControl+C detected, attempting to stop service.
Service MyApp.MyApp stopped
The MyAppService service has stopped.
</code></pre>
<p>And that&rsquo;s it, the same code compiles on Linux as well, and runs successfully.</p>
<p>I&rsquo;m not currently a Linux user and haven&rsquo;t set up services or daemons for a while, so I will defer to others on the topic of <a href="http://pmcgrath.net/running-a-simple-dotnet-core-linux-daemon">Running a dotnet Core app as a Linux daemon</a></p>
<h3 id="on-docker">On Docker</h3>
<p>Let&rsquo;s whip up a Dockerfile to round it off, that will build and pack a new docker image, that we can then start and see it running our task.</p>
<p>First the docker file (Dockerfile). This is a basic minimalist version, you will likely want to do optimisation steps yourself.</p>
<pre><code class="language-dockerfile">FROM microsoft/dotnet:2.0-runtime AS base
WORKDIR /app
EXPOSE 80

FROM microsoft/aspnetcore-build:2.0 AS build
WORKDIR /src
COPY . .
RUN dotnet build -c Release -o /app

FROM build AS publish
RUN dotnet publish -c Release -o /app

FROM base AS final
WORKDIR /app
COPY --from=publish /app .
ENTRYPOINT [&quot;dotnet&quot;, &quot;MyApp.dll&quot;]
</code></pre>
<p>This will use the <code>Microsoft/aspnetcore-build:2.0</code> container image as the build container, publish the results and produce a packed container based on the <code>Microsoft/dotnet:2.0-runtime</code> container image. We are also setting the container with an entry point to start the application process as the main container process. This means that if/when the process stops, the container terminates.</p>
<p>We run the build command, asking it to tag the created image as <code>myapptestcontainer:latest</code> so we can refer to it again in a moment.</p>
<pre><code class="language-powershell">docker build -t myapptestcontainer:latest .
</code></pre>
<pre><code class="language-shell">Sending build context to Docker daemon  136.7kB
Step 1/13 : FROM microsoft/dotnet:2.0-runtime AS base
 ---&gt; 26314e3adaec
Step 2/13 : WORKDIR /app
Removing intermediate container 9296d10905ce
 ---&gt; 8794c7aca866
Step 3/13 : EXPOSE 80
 ---&gt; Running in 6554f663146f
Removing intermediate container 6554f663146f
 ---&gt; ad881b2a405e
Step 4/13 : FROM microsoft/aspnetcore-build:2.0 AS build
 ---&gt; 244f6193d21a
Step 5/13 : WORKDIR /src
Removing intermediate container a38fb58535b6
 ---&gt; 5ed2a92fda93
Step 6/13 : COPY . .
 ---&gt; 8ffd3faa7bc9
Step 7/13 : RUN dotnet build -c Release -o /app
 ---&gt; Running in 39d44616ea2d
Microsoft (R) Build Engine version 15.6.82.30579 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restoring packages for /src/MyApp.csproj...
  Installing System.ServiceProcess.ServiceController 4.4.0.
  Installing PeterKottas.DotNetCore.CmdArgParser 1.0.5.
  Installing DasMulli.Win32.ServiceUtils 1.0.1.
  Installing PeterKottas.DotNetCore.WindowsService 2.0.6.
  Generating MSBuild file /src/obj/MyApp.csproj.nuget.g.props.
  Restore completed in 2.72 sec for /src/MyApp.csproj.
  MyApp -&gt; /app/MyApp.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:06.14
Removing intermediate container 39d44616ea2d
 ---&gt; 56b58883d64b
Step 8/13 : FROM build AS publish
 ---&gt; 56b58883d64b
Step 9/13 : RUN dotnet publish -c Release -o /app
 ---&gt; Running in 552eb703a748
Microsoft (R) Build Engine version 15.6.82.30579 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restore completed in 131.4 ms for /src/MyApp.csproj.
  MyApp -&gt; /src/bin/Release/netcoreapp2.0/MyApp.dll
  MyApp -&gt; /app/
Removing intermediate container 552eb703a748
 ---&gt; 474498c42be3
Step 10/13 : FROM base AS final
 ---&gt; ad881b2a405e
Step 11/13 : WORKDIR /app
Removing intermediate container c3c0dd6ac31c
 ---&gt; 02c236862201
Step 12/13 : COPY --from=publish /app .
 ---&gt; 33509849efe0
Step 13/13 : ENTRYPOINT [&quot;dotnet&quot;, &quot;MyApp.dll&quot;]
 ---&gt; Running in 25b373135eb6
Removing intermediate container 25b373135eb6
 ---&gt; 511aa92712d1
Successfully built 511aa92712d1
Successfully tagged myapptestcontainer:latest
</code></pre>
<p>Now that we have a successful image for our app, we can start and run instances of it on docker, as well. We do this using the <code>docker run</code> command.</p>
<p>As before, we can run this interactively using the -it command:</p>
<pre><code class="language-powershell">docker run --rm -it myapptestcontainer:latest
</code></pre>
<pre><code class="language-shell">Starting up as a console service host
Service MyApp.MyApp started
The MyAppService service is now running, press Control+C to exit.
1
1
2
3
5
8
13
21
34
55
89
^CControl+C detected, attempting to stop service.
Service MyApp.MyApp stopped
The MyAppService service has stopped.
</code></pre>
<p>And Control+C still works as expected. The real proof is launching it and checking the processes. We will:</p>
<ul>
<li>Run an instance from our image, detached (<code>docker run -d myapptestcontainer:latest</code>)</li>
<li>See that it is running using list process (<code>docker ps</code>)</li>
<li>Stop the process (<code>docker stop &lt;pid&gt;</code>)</li>
<li>Print the logs (<code>docker logs &lt;pid&gt;</code>)</li>
<li>Clean up the process (<code>docker rm &lt;pid&gt;</code>)</li>
</ul>
<pre><code class="language-shell">&gt; docker run -d myapptestcontainer:latest
5a11b3ee222d35196f7d7549d634cd8b8c9220bfb4f9dd9f7fd577b094b2bccb

&gt; docker ps
CONTAINER ID        IMAGE                       COMMAND              CREATED             STATUS              PORTS               NAMES
5a11b3ee222d        myapptestcontainer:latest   &quot;dotnet MyApp.dll&quot;   2 seconds ago       Up 1 second         80/tcp              musing_montalcini

&gt; docker stop 5a11b
5a11b

&gt; docker logs 5a11b
Starting up as a console service host
Service MyApp.MyApp started
The MyAppService service is now running, press Control+C to exit.
1
1
2
3
5

&gt; docker rm 5a11b
5a11b
</code></pre>
<p>As we can see, the only difference is the termination. Linux is sending the termination message correctly, but the library we are using doesn&rsquo;t subscribe to the correct callback (<code>AppDomain.CurrentDomain.ProcessExit</code> perhaps) and so instead the process is just terminated.</p>
<p>Now I started raising this as a bug against the library, but had to stop myself and ask &ldquo;Do I really need this?&rdquo;  There are a bunch of reasons and ways your container could get terminated. You need to build in resilience for this termination.  For that reason, you need to allow for you process to die in the middle of any part of your code and figure out ways to gracefully recover as needed. (Think about how SQL Server recovers after a termination to avoid data loss.) For this reason, I don&rsquo;t see the fact that <code>OnShutdown</code> doesn&rsquo;t get called as a bug, but instead an opportunity to write a better process.</p>
<p>Of course, if you absolutely want this behaviour, you could do something like <a href="https://github.com/PeterKottas/DotNetCore.WindowsService/issues/52#issuecomment-344853011">this stack overflow comment suggests</a> and connect the handler yourself, calling into the appropriate function. Like replacing the Service factory with the following:</p>
<pre><code class="language-cs">serviceConfig.ServiceFactory((extraArguments, serviceController) =&gt;
{
    var myApp = new MyApp();
    EventHandler handler = null;
    handler = (sender, _) =&gt;
    {
        AppDomain.CurrentDomain.ProcessExit -= handler;
        Console.WriteLine(&quot;Process Exit triggered&quot;, name);
        myApp.Stop();
    };
    AppDomain.CurrentDomain.ProcessExit += handler;
    return myApp;
});
</code></pre>
<p>Just make sure if you do decide to use this, that your stop function is <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a> and only runs once.</p>
<h3 id="the-end">The End</h3>
<p>I hope this article helps others coming to find out how to create cross-platform services with .Net Core. Also hopefully it redeems me for confusing so many people who landed on my <a href="/building-a-windows-service-with-net-core/">Building a Windows Service with .Net Core</a> article as well.</p>
<p>Simple. Easy. Works<a href="https://blog.codinghorror.com/the-works-on-my-machine-certification-program/">.</a></p>
</description>
    </item>
    
    <item>
      <title>.Net Core SDK 2.* Series - Self-contained Applications</title>
      <link>https://csmacnzblog.github.io/post/dotnetcore2-self-contained-applications/</link>
      <pubDate>Sun, 18 Mar 2018 20:18:22 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/dotnetcore2-self-contained-applications/</guid>
      <description><p>This is a series on the latest 2.* .Net Core bits, Following on from the original <a href="https://blog.csmac.nz/dotnetcore-getting-started">.Net Core Series</a></p>
<ul>
<li><a href="/dotnetcore2-getting-started">Getting Started</a></li>
<li><a href="/dotnetcore2-whats-in-the-box">What&rsquo;s in the box</a></li>
<li><a href="/dotnetcore2-using-multiple-projects">Using Multiple Projects</a></li>
<li><a href="/dotnetcore2-testing">Testing</a></li>
<li><a href="/dotnetcore2-nuget">NuGet</a></li>
<li><a href="/dotnetcore2-multi-targeting">Multi-targeting</a></li>
<li><a href="/dotnetcore2-publishing-portable-applications">Publishing Portable Applications</a></li>
<li>Self-contained Applications &lt;=(We are here)</li>
</ul>
<p>(At the time of writing, 2.1.4. I use windows, you don&rsquo;t have to!)</p>
<h3 id="the-problem">The Problem</h3>
<p>Distributing the fruits of your labour is one of the rewarding parts of building any kind of software. People actually start to use it!  But distribution is never as easy as it should be. With .Net Core Applications, the story can be a similar one.</p>
<p>Traditionally, distributing a .Net Application means requiring a runtime on the target machine. While .Net isn&rsquo;t the only platform to work this way, It has meant a bit of dependency wrangling on the target machine before you can run your app. Again, by no means is this as terrible an experience, or as painful as other platforms &amp; runtimes can be, but you need to be aware of it.</p>
<p>With <code>netcoreapp*</code> applications this is no different. While using the latest SDK can target multiple runtime versions and platforms (including older versions), and can pull down the right files for building against, you may find that unless you install the correct runtime, you won&rsquo;t be able to run what you build. This is true even with the SDKs for the same major version are installed.</p>
<p>Let&rsquo;s first take a look at how we can install different target runtime versions, then we can see how we can remove the need for this altogether.</p>
<h3 id="installing-multiple-platforms">Installing Multiple Platforms</h3>
<p>One option on your development machine is to install everything.</p>
<p><a href="https://www.microsoft.com/net/download/all">This page</a> has all the download links for all the different versions of .Net Core. You could download all these installers and install all the SDKs and runtimes.</p>
<p>If you do that, you can then run any version of .Net Core applications, and also build using any version of the SDK.  You will have to install them in order from oldest to newest (especially true of the sdks) or some might not install properly. (All I mean is that installing oldest to newest will install everything as intended, but doing so out of order may not produce the desired result.)</p>
<p>But who has time for that? Automation anyone?</p>
<p>There are a set of <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/dotnet-install-script">dotnet-install scripts</a>, both in Bash and PowerShell formats, that allow you to script the installation of dotnet runtimes. By default, these scripts will install the latest version into your user profile, but there are a tonne of options you can choose from.</p>
<p>There are a couple of ways to run the script, either download and execute as one command, or save the file, then execute it. (Shown below in PowerShell command format.)</p>
<pre><code class="language-ps"># Download and Execute the script in one command
&quot;&amp;([scriptblock]::Create((Invoke-WebRequest -useb 'https://dot.net/v1/dotnet-install.ps1'))) -DryRun&quot;

#Alternatively save the script, then execute it
Invoke-WebRequest -useb 'https://dot.net/v1/dotnet-install.ps1' -OutFile &quot;dotn
et-install.ps1&quot;
.\dotnet-install.ps1 -DryRun
</code></pre>
<p>(I&rsquo;ve used <code>-DryRun</code> argument to test the script parameters, before actually making changes.)</p>
<p>Let&rsquo;s see how to use the script in two ways: First to install the equivalent of the way the installers would onto your machine. (You will need an Administrator Prompt for this.)</p>
<pre><code># This assumes your ${Env:ProgramFiles(x86)} is set to &quot;C:\Program Files (x86)&quot;
# Your default Program Files directory might be different otherwise.

.\dotnet-install.ps1 -Version 2.1.4 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot;

# You can do this for other SDK versions
.\dotnet-install.ps1 -Version 2.0.3 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot;
.\dotnet-install.ps1 -Version 1.1.7 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot;
.\dotnet-install.ps1 -Version 1.1.5 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot;
.\dotnet-install.ps1 -Version 1.0.4 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot;

# And for other runtimes
.\dotnet-install.ps1 -Version 2.0.5 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot; -SharedRuntime
.\dotnet-install.ps1 -Version 2.0.3 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot; -SharedRuntime
.\dotnet-install.ps1 -Version 2.0.0 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot; -SharedRuntime
.\dotnet-install.ps1 -Version 1.1.6 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot; -SharedRuntime
.\dotnet-install.ps1 -Version 1.1.5 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot; -SharedRuntime
.\dotnet-install.ps1 -Version 1.0.9 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot; -SharedRuntime
.\dotnet-install.ps1 -Version 1.0.8 -InstallDir &quot;C:\Program Files (x86)\dotnet&quot; -SharedRuntime

</code></pre>
<p>If you haven&rsquo;t already run an installer for any versions of dotnet SDK, you will probably have to manually add <code>C:\Program Files (x86)\dotnet</code> to your PATH Environment Variable. By default it will be made immediately available for the current console window session.</p>
<p>Next let&rsquo;s look at doing the same thing into a stand-alone folder on your machine instead.</p>
<pre><code># Install the latest/current stable SDK first
.\dotnet-install.ps1 -Channel Current -InstallDir C:\dotnet-cli

# Now other required SDKs
.\dotnet-install.ps1 -Version 2.1.4 -InstallDir C:\dotnet-cli # Should be the same as Current at the time of writing
.\dotnet-install.ps1 -Version 2.0.3 -InstallDir C:\dotnet-cli
.\dotnet-install.ps1 -Version 1.1.7 -InstallDir C:\dotnet-cli
.\dotnet-install.ps1 -Version 1.1.5 -InstallDir C:\dotnet-cli
.\dotnet-install.ps1 -Version 1.0.4 -InstallDir C:\dotnet-cli
.\dotnet-install.ps1 -Version 1.0.1 -InstallDir C:\dotnet-cli

# Now all the required runtimes
.\dotnet-install.ps1 -Version 2.0.5 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 2.0.3 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 2.0.0 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.1.6 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.1.5 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.1.2 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.1.1 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.1.0 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.0.9 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.0.8 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.0.4 -InstallDir C:\dotnet-cli -SharedRuntime
.\dotnet-install.ps1 -Version 1.0.3 -InstallDir C:\dotnet-cli -SharedRuntime

</code></pre>
<p>As mentioned before, for the current session you will find the newly installed <code>dotnet.exe</code> set in your path pointing at the new folders, but You will also need to manually put this into your PATH Environment variable to make this version always available as the default <code>dotnet</code> command.</p>
<h3 id="but-why-a-runtime">But why a Runtime?</h3>
<p>Why do we need to install the target runtime? Well, mainly it is because we want to keep our application distribution small. We do this by leaving out a bunch of common framework executable code, that we entrust to a runtime distribution to deliver to the target machine for us.  This runtime can be shared across applications and so they will all get the benefit of being smaller.</p>
<p>But what if we don&rsquo;t want to share? Traditionally this hasn&rsquo;t been much of an option. For certain <code>dll</code> files, we can distribute them with our app to ensure the correct one is chosen, rather than relying on the system to find them for us. But this isn&rsquo;t generally true for all parts of the framework, especially more crucial low-level system details. (And sometimes the installed framework will override us anyway - &ldquo;GAC DLL hell&rdquo; or &ldquo;dee el hell&rdquo; is what we called it.)</p>
<h3 id="look-mum-no-runtime">Look Mum, No Runtime!</h3>
<p>But .Net Core&hellip;</p>
<p>Yes, now with .Net Core, there is a way to bundle the entire (yes all!) specific (exact version!) runtime with your application.</p>
<p>This has two main benefits:</p>
<ul>
<li>We do not require anything* to be pre-installed on the target machine.</li>
<li>We can ensure exactly the right set of libraries and code is running with our application, down to the framework bugs at the time of packaging.</li>
</ul>
<p>Just so this doesn&rsquo;t sound too Silver-Bullet-y, a few quick drawbacks, too:</p>
<ul>
<li>Your distributable won&rsquo;t be small anymore. (~60mb to start, just for the runtime)</li>
<li>You will be distributing against a specific platform (Operating System), and may need multiple packages, one per Operating System target.</li>
</ul>
<p>It is up to you to decide the trade-offs that make the most sense for your application.</p>
<h3 id="show-me-the-code">Show me the Code!</h3>
<pre><code>mkdir MySelfContainedApp
cd MySelfContainedApp
mkdir MyApp
cd MyApp
dotnet new console
cd ../
dotnet new sln
dotnet sln add .\MyApp\MyApp.csproj
dotnet build
</code></pre>
<p>Once we have an app to use, this is how we package it with its own runtime:</p>
<pre><code>dotnet publish --self-contained --runtime win7-x64
</code></pre>
<p>(Not using Windows? Other runtime values include <code>osx.10.12-x64</code> and <code>ubuntu.16.04-x64</code>. A full list and description of them all can be found in the <a href="https://docs.microsoft.com/en-nz/dotnet/core/rid-catalog">rid catalog</a>)</p>
<p>The runtime identifier <code>win7-x64</code> means we will package with a runtime compatible with the Windows 7(&amp; Windows Server 2008 R2) Operating System, 64-bit Architecture. This means that it will run on those Operating Systems, and should be forward-compatible to newer systems (compatibility). (It also means there may be performance optimisations from newer systems like <code>Win8</code> and <code>Win10</code> that won&rsquo;t be taken advantage of when it runs in Compatability mode on the newer OS versions.)  It also states that it requires a 64-bit Architecture. no 32-bit Architecture machines will be able to run the application. (You may recall building apps in the past that could target <code>AnyCPU</code>. This isn&rsquo;t it.)</p>
<p>In general, you can identify Operating System, OS Version, and architecture from the parts of an rid. This is representative, and should not be relied on as a composition of any OS/Version/Arch into an rid. Use the reference guide to ensure you are using valid identifiers.</p>
<p>As well as specific runtimes, SDK 2.0 introduces Portable rids. <code>Win-x64</code>, <code>linux-x64</code> and <code>osx-x64</code> give you version-agnostic Operating System Targets. (Most useful for Linux, since it is across multiple distros - Ubuntu, Tizen, Red Hat, Fedora etc etc.) This doesn&rsquo;t necessarily affect the size, mostly just the compatibility. (Affects Performance/Optimisations? Possibly. Perf test if you want to find out! 😉 )</p>
<p>Let&rsquo;s take a look at the output from our publish command:</p>
<pre><code>MySelfContainedApp
|-- MySelfContainedApp.sln
+---MyApp
    |-- MyApp.csproj
    |-- Program.cs
    +-- bin
        +-- Debug
            +-- netcoreapp2.0
                |-- MyApp.deps.json
                |-- MyApp.dll
                |-- MyApp.pdb
                |-- MyApp.runtimeconfig.dev.json
                |-- MyApp.runtimeconfig.json
                +-- win7-x64
                    |-- hostfxr.dll
                    |-- hostpolicy.dll
                    |-- MyApp.deps.json
                    |-- MyApp.dll
                    |-- MyApp.exe
                    |-- MyApp.pdb
                    |-- MyApp.runtimeconfig.dev.json
                    |-- MyApp.runtimeconfig.json
                    |--
                    +-- publish
                        |-- api-ms-win-core-console-l1-1-0.dll
                        |-- api-ms-win-core-datetime-l1-1-0.dll
                        |-- api-ms-win-core-debug-l1-1-0.dll
                        |-- api-ms-win-core-errorhandling-l1-1-0.dll
                        |-- api-ms-win-core-file-l1-1-0.dll
                        |-- api-ms-win-core-file-l1-2-0.dll
                        |-- api-ms-win-core-file-l2-1-0.dll
                        |-- api-ms-win-core-handle-l1-1-0.dll
                        |-- api-ms-win-core-heap-l1-1-0.dll
                        |-- api-ms-win-core-interlocked-l1-1-0.dll
                        |-- api-ms-win-core-libraryloader-l1-1-0.dll
                        |-- api-ms-win-core-localization-l1-2-0.dll
                        |-- api-ms-win-core-memory-l1-1-0.dll
                        |-- api-ms-win-core-namedpipe-l1-1-0.dll
                        |-- api-ms-win-core-processenvironment-l1-1-0.dll
                        |-- api-ms-win-core-processthreads-l1-1-0.dll
                        |-- api-ms-win-core-processthreads-l1-1-1.dll
                        |-- api-ms-win-core-profile-l1-1-0.dll
                        |-- api-ms-win-core-rtlsupport-l1-1-0.dll
                        |-- api-ms-win-core-string-l1-1-0.dll
                        |-- api-ms-win-core-synch-l1-1-0.dll
                        |-- api-ms-win-core-synch-l1-2-0.dll
                        |-- api-ms-win-core-sysinfo-l1-1-0.dll
                        |-- api-ms-win-core-timezone-l1-1-0.dll
                        |-- api-ms-win-core-util-l1-1-0.dll
                        |-- api-ms-win-crt-conio-l1-1-0.dll
                        |-- api-ms-win-crt-convert-l1-1-0.dll
                        |-- api-ms-win-crt-environment-l1-1-0.dll
                        |-- api-ms-win-crt-filesystem-l1-1-0.dll
                        |-- api-ms-win-crt-heap-l1-1-0.dll
                        |-- api-ms-win-crt-locale-l1-1-0.dll
                        |-- api-ms-win-crt-math-l1-1-0.dll
                        |-- api-ms-win-crt-multibyte-l1-1-0.dll
                        |-- api-ms-win-crt-private-l1-1-0.dll
                        |-- api-ms-win-crt-process-l1-1-0.dll
                        |-- api-ms-win-crt-runtime-l1-1-0.dll
                        |-- api-ms-win-crt-stdio-l1-1-0.dll
                        |-- api-ms-win-crt-string-l1-1-0.dll
                        |-- api-ms-win-crt-time-l1-1-0.dll
                        |-- api-ms-win-crt-utility-l1-1-0.dll
                        |-- clrcompression.dll
                        |-- clretwrc.dll
                        |-- clrjit.dll
                        |-- coreclr.dll
                        |-- dbgshim.dll
                        |-- hostfxr.dll
                        |-- hostpolicy.dll
                        |-- Microsoft.CSharp.dll
                        |-- Microsoft.DiaSymReader.Native.amd64.dll
                        |-- Microsoft.VisualBasic.dll
                        |-- Microsoft.Win32.Primitives.dll
                        |-- Microsoft.Win32.Registry.dll
                        |-- mscordaccore.dll
                        |-- mscordaccore_amd64_amd64_4.6.00001.0.dll
                        |-- mscordbi.dll
                        |-- mscorlib.dll
                        |-- mscorrc.debug.dll
                        |-- mscorrc.dll
                        |-- MyApp.deps.json
                        |-- MyApp.dll
                        |-- MyApp.exe
                        |-- MyApp.pdb
                        |-- MyApp.runtimeconfig.json
                        |-- netstandard.dll
                        |-- sos.dll
                        |-- SOS.NETCore.dll
                        |-- sos_amd64_amd64_4.6.00001.0.dll
                        |-- System.AppContext.dll
                        |-- System.Buffers.dll
                        |-- System.Collections.Concurrent.dll
                        |-- System.Collections.dll
                        |-- System.Collections.Immutable.dll
                        |-- System.Collections.NonGeneric.dll
                        |-- System.Collections.Specialized.dll
                        |-- System.ComponentModel.Annotations.dll
                        |-- System.ComponentModel.Composition.dll
                        |-- System.ComponentModel.DataAnnotations.dll
                        |-- System.ComponentModel.dll
                        |-- System.ComponentModel.EventBasedAsync.dll
                        |-- System.ComponentModel.Primitives.dll
                        |-- System.ComponentModel.TypeConverter.dll
                        |-- System.Configuration.dll
                        |-- System.Console.dll
                        |-- System.Core.dll
                        |-- System.Data.Common.dll
                        |-- System.Data.dll
                        |-- System.Diagnostics.Contracts.dll
                        |-- System.Diagnostics.Debug.dll
                        |-- System.Diagnostics.DiagnosticSource.dll
                        |-- System.Diagnostics.FileVersionInfo.dll
                        |-- System.Diagnostics.Process.dll
                        |-- System.Diagnostics.StackTrace.dll
                        |-- System.Diagnostics.TextWriterTraceListener.dll
                        |-- System.Diagnostics.Tools.dll
                        |-- System.Diagnostics.TraceSource.dll
                        |-- System.Diagnostics.Tracing.dll
                        |-- System.dll
                        |-- System.Drawing.dll
                        |-- System.Drawing.Primitives.dll
                        |-- System.Dynamic.Runtime.dll
                        |-- System.Globalization.Calendars.dll
                        |-- System.Globalization.dll
                        |-- System.Globalization.Extensions.dll
                        |-- System.IO.Compression.dll
                        |-- System.IO.Compression.FileSystem.dll
                        |-- System.IO.Compression.ZipFile.dll
                        |-- System.IO.dll
                        |-- System.IO.FileSystem.AccessControl.dll
                        |-- System.IO.FileSystem.dll
                        |-- System.IO.FileSystem.DriveInfo.dll
                        |-- System.IO.FileSystem.Primitives.dll
                        |-- System.IO.FileSystem.Watcher.dll
                        |-- System.IO.IsolatedStorage.dll
                        |-- System.IO.MemoryMappedFiles.dll
                        |-- System.IO.Pipes.dll
                        |-- System.IO.UnmanagedMemoryStream.dll
                        |-- System.Linq.dll
                        |-- System.Linq.Expressions.dll
                        |-- System.Linq.Parallel.dll
                        |-- System.Linq.Queryable.dll
                        |-- System.Net.dll
                        |-- System.Net.Http.dll
                        |-- System.Net.HttpListener.dll
                        |-- System.Net.Mail.dll
                        |-- System.Net.NameResolution.dll
                        |-- System.Net.NetworkInformation.dll
                        |-- System.Net.Ping.dll
                        |-- System.Net.Primitives.dll
                        |-- System.Net.Requests.dll
                        |-- System.Net.Security.dll
                        |-- System.Net.ServicePoint.dll
                        |-- System.Net.Sockets.dll
                        |-- System.Net.WebClient.dll
                        |-- System.Net.WebHeaderCollection.dll
                        |-- System.Net.WebProxy.dll
                        |-- System.Net.WebSockets.Client.dll
                        |-- System.Net.WebSockets.dll
                        |-- System.Numerics.dll
                        |-- System.Numerics.Vectors.dll
                        |-- System.ObjectModel.dll
                        |-- System.Private.CoreLib.dll
                        |-- System.Private.DataContractSerialization.dll
                        |-- System.Private.Uri.dll
                        |-- System.Private.Xml.dll
                        |-- System.Private.Xml.Linq.dll
                        |-- System.Reflection.DispatchProxy.dll
                        |-- System.Reflection.dll
                        |-- System.Reflection.Emit.dll
                        |-- System.Reflection.Emit.ILGeneration.dll
                        |-- System.Reflection.Emit.Lightweight.dll
                        |-- System.Reflection.Extensions.dll
                        |-- System.Reflection.Metadata.dll
                        |-- System.Reflection.Primitives.dll
                        |-- System.Reflection.TypeExtensions.dll
                        |-- System.Resources.Reader.dll
                        |-- System.Resources.ResourceManager.dll
                        |-- System.Resources.Writer.dll
                        |-- System.Runtime.CompilerServices.VisualC.dll
                        |-- System.Runtime.dll
                        |-- System.Runtime.Extensions.dll
                        |-- System.Runtime.Handles.dll
                        |-- System.Runtime.InteropServices.dll
                        |-- System.Runtime.InteropServices.RuntimeInformation.dll
                        |-- System.Runtime.InteropServices.WindowsRuntime.dll
                        |-- System.Runtime.Loader.dll
                        |-- System.Runtime.Numerics.dll
                        |-- System.Runtime.Serialization.dll
                        |-- System.Runtime.Serialization.Formatters.dll
                        |-- System.Runtime.Serialization.Json.dll
                        |-- System.Runtime.Serialization.Primitives.dll
                        |-- System.Runtime.Serialization.Xml.dll
                        |-- System.Security.AccessControl.dll
                        |-- System.Security.Claims.dll
                        |-- System.Security.Cryptography.Algorithms.dll
                        |-- System.Security.Cryptography.Cng.dll
                        |-- System.Security.Cryptography.Csp.dll
                        |-- System.Security.Cryptography.Encoding.dll
                        |-- System.Security.Cryptography.OpenSsl.dll
                        |-- System.Security.Cryptography.Primitives.dll
                        |-- System.Security.Cryptography.X509Certificates.dll
                        |-- System.Security.dll
                        |-- System.Security.Principal.dll
                        |-- System.Security.Principal.Windows.dll
                        |-- System.Security.SecureString.dll
                        |-- System.ServiceModel.Web.dll
                        |-- System.ServiceProcess.dll
                        |-- System.Text.Encoding.dll
                        |-- System.Text.Encoding.Extensions.dll
                        |-- System.Text.RegularExpressions.dll
                        |-- System.Threading.dll
                        |-- System.Threading.Overlapped.dll
                        |-- System.Threading.Tasks.Dataflow.dll
                        |-- System.Threading.Tasks.dll
                        |-- System.Threading.Tasks.Extensions.dll
                        |-- System.Threading.Tasks.Parallel.dll
                        |-- System.Threading.Thread.dll
                        |-- System.Threading.ThreadPool.dll
                        |-- System.Threading.Timer.dll
                        |-- System.Transactions.dll
                        |-- System.Transactions.Local.dll
                        |-- System.ValueTuple.dll
                        |-- System.Web.dll
                        |-- System.Web.HttpUtility.dll
                        |-- System.Windows.dll
                        |-- System.Xml.dll
                        |-- System.Xml.Linq.dll
                        |-- System.Xml.ReaderWriter.dll
                        |-- System.Xml.Serialization.dll
                        |-- System.Xml.XDocument.dll
                        |-- System.Xml.XmlDocument.dll
                        |-- System.Xml.XmlSerializer.dll
                        |-- System.Xml.XPath.dll
                        |-- System.Xml.XPath.XDocument.dll
                        |-- ucrtbase.dll
                        \-- WindowsBase.dll
</code></pre>
<p>That publish folder is 62.7 MB! Compare that to the size of the files in <code>MySelfContainedApp\MyApp\bin\Debug\netcoreapp2.0</code>, which are only 5.76 KB. Compared to the app, that is a lot of Runtime to carry around. (The application is less than a percent of the total distributable size)</p>
<p>This is a considerable tradeoff and should be considered carefully when making the decision between packing portable or distributing the runtime.</p>
<h3 id="the-cake-is-a-lie">The Cake is a Lie</h3>
<p>I said earlier that one of the benefits of distributing the runtime was <code>We do not require anything* to be pre-installed on the target machine.</code></p>
<p>The * was &ldquo;with a few exceptions&rdquo;.</p>
<p>Windows being Windows, you still actually need one more thing. <a href="https://www.microsoft.com/download/details.aspx?id=52685">Microsoft Visual C++ 2015 Redistributable Update 3</a> is needed for the packaged runtime to work on windows. This gets installed if required by the dotnet installer, but won&rsquo;t be in your self-contained package. (It also isn&rsquo;t installed if you use the <code>dotnet-install.ps1</code> script from earlier, either.) It is likely that something else will require this Redistributable on windows anyway, so this isn&rsquo;t a big deal, really.</p>
<p>You can take a look at <a href="https://docs.microsoft.com/en-nz/dotnet/core/windows-prerequisites">Prerequisites for .NET Core on Windows</a> for more information on this.</p>
<p>Linux doesn&rsquo;t escape unscathed either. Dependency graphs on Linux distros can get a bit overwhelming at the best of times. That is why we have package managers and installers. Due to the variance of distros, I can&rsquo;t tell you what you will or won&rsquo;t need here. First, see <a href="https://docs.microsoft.com/en-nz/dotnet/core/linux-prerequisites">Prerequisites for .NET Core on Linux</a> for more information in general. Then specifically you will want to check out the <a href="https://github.com/dotnet/core/blob/master/Documentation/self-contained-linux-apps.md">Self-contained Linux applications</a> documentation.</p>
<p>For some reason, MacOS is fine? Apart from a minimum version (macOS 10.12 &ldquo;Sierra&rdquo; and later) and something about <a href="https://docs.microsoft.com/en-nz/dotnet/core/macos-prerequisites?tabs=netcore2x#increase-the-maximum-open-file-limit">increasing the open file limit</a>, there isn&rsquo;t much else you need to do. Something to be said for standard software and hardware, I suppose.</p>
<h3 id="wrap-up">Wrap up</h3>
<p>So there you have it. You have the choice available to you. You can package one ~5kb portable application (in reality maybe ~5mb) and distribute it, requiring the correct runtime version to be already installed, or you can package in the correct runtime with you app for an extra ~60mb, and build and package at least 3 times to cover windows, Linux and Mac operating systems. (And still require some dependencies anyway).</p>
<p>IF you are bundling an app(game?) that includes a lot of assets and is already distributing 2GB of software, that extra 60Mb is not a big deal, but in general that ratio is rather large.</p>
<p>Of course, this is more than about size, because we can guarantee the compatibility as well because we will have tested our application with exactly the right runtime version that we distribute with.</p>
<p>The choice is yours.</p>
<p>At some point, I will have to experiment and write about how we might get that size down (there are a few ways I am aware of) so we may still get the best of both worlds.</p>
<h2 id="the-end">The End</h2>
<p>Thank you so much for getting this far. It has been a long journey from <a href="/dotnetcore-getting-started">Getting Started with 1.0</a> almost 2 years ago to get here across these new 8 articles. Thanks for sticking with it. I hope you look forward to more .Net Core blog articles to come. Maybe even a revised 3.* version? (Take your time, MS)</p>
<p>You can find related articles using the <a href="https://blog.csmac.nz/tag/dotnetcore/">dotnetcore tag</a>.</p>
</description>
    </item>
    
    <item>
      <title>.Net Core SDK 2.* Series - Publishing Portable Applications</title>
      <link>https://csmacnzblog.github.io/post/dotnetcore2-publishing-portable-applications/</link>
      <pubDate>Sun, 11 Mar 2018 06:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/dotnetcore2-publishing-portable-applications/</guid>
      <description><p>This is a series on the latest 2.* .Net Core bits, Following on from the original <a href="https://blog.csmac.nz/dotnetcore-getting-started">.Net Core Series</a></p>
<ul>
<li><a href="/dotnetcore2-getting-started">Getting Started</a></li>
<li><a href="/dotnetcore2-whats-in-the-box">What&rsquo;s in the box</a></li>
<li><a href="/dotnetcore2-using-multiple-projects">Using Multiple Projects</a></li>
<li><a href="/dotnetcore2-testing">Testing</a></li>
<li><a href="/dotnetcore2-nuget">NuGet</a></li>
<li><a href="/dotnetcore2-multi-targeting">Multi-targeting</a></li>
<li>Publishing Portable Applications &lt;=(We are here)</li>
<li><a href="/dotnetcore2-self-contained-applications">Self-contained Applications</a></li>
</ul>
<p>(At the time of writing, 2.1.4. I use windows, you don&rsquo;t have to!)</p>
<p>We can now take everything we have learned and start publishing our applications. Luckily, there is a command for that too.</p>
<h3 id="the-setup">The Setup</h3>
<p>I don&rsquo;t know why I bother saying anything here, this is pretty straight-forward by now.</p>
<pre><code>mkdir MyPackagedApp
cd MyPackagedApp
mkdir MyApp
cd MyApp
dotnet new console
cd ../
dotnet new sln
dotnet sln add .\MyApp\MyApp.csproj
dotnet build
</code></pre>
<p>And again, we replace the contents of Program.cs. This time, let&rsquo;s try printing a few verses of <a href="http://www.djron.com/jokes/suess.html">Dr. Seuss Explaining Computers</a></p>
<pre><code>using System;

namespace MyApp
{
    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine(&quot;Dr. Seuss Explains Computers&quot;);
            Console.WriteLine(&quot;============================&quot;);
            Console.WriteLine(&quot;&quot;);
            Console.WriteLine(&quot;If a Packet Hits a pocket on a socket on a port, and the bus is interrupted as a very last resort, and the address of the memory makes your floppy disk abort, then the socket packet pocket has an error to report.&quot;);
            Console.WriteLine(&quot;If your cursor finds a menu item followed by a dash, and the double-clicking icon puts your window in the trash, and your data is corrupted 'cause the index doesn't hash, then the situation's hopeless and your systems gonna crash!&quot;);
            Console.WriteLine(&quot;&quot;);
            Console.WriteLine(&quot;&quot;);
            Console.WriteLine(&quot;Read the rest at: http://computerjokes.net/112.asp&quot;);
            Console.WriteLine(&quot;&quot;);
        }
    }
}
</code></pre>
<p>And for good measure another build.</p>
<pre><code>dotnet build
</code></pre>
<h3 id="publishing">Publishing</h3>
<p>To publish our application we use the most obvious of commands. As before with <code>dotnet test</code>, running this against the solution will result in publishing all projects that are publishable.</p>
<pre><code>dotnet publish
</code></pre>
<p>Which results in the following file structure.</p>
<pre><code>MyPackagedApp
 +-- MyApp
      |-- MyApp.csproj
      |-- Program.cs
      +-- bin
           +-- Debug
                +-- netcoreapp2.0
                     |-- MyApp.deps.json
                     |-- MyApp.dll
                     |-- MyApp.pdb
                     |-- MyApp.runtimeconfig.dev.json
                     |-- MyApp.runtimeconfig.json
                     +-- publish
                          |-- MyApp.deps.json
                          |-- MyApp.dll
                          |-- MyApp.pdb
                          \-- MyApp.runtimeconfig.json
</code></pre>
<p>The <code>publish</code> command adds a new build artifact folder - <code>publish</code>. Inside are all of the files for the application to distribute (to someone who has the runtime available). In this case, our application is a <code>netcoreapp2.0</code> app, so the distribution is the <code>dll</code>, to run with .Net Core runtime.</p>
<p>We can execute our application using the command <code>dotnet MyApp.dll</code> from inside the publish folder, or from the project folder using a relative path <code>dotnet .\MyApp\bin\Debug\netcoreapp2.0\MyApp.dll</code>.</p>
<h4 id="output-folder">Output folder</h4>
<p>We probably want to publish to a different location, so we can use the option <code>-o &lt;OUTPUT_PATH&gt;</code> to publish somewhere else. At the same time, we might use the <code>-c &lt;CONFIGURATION&gt;</code> option to specify a release build. (Note that output path is relative to the folder containing the <code>csproj</code>, not the folder running the command.)</p>
<pre><code>dotnet publish -o &quot;../Pack/MyApp&quot; -c Release
</code></pre>
<p>Which will give you the following in the new Pack folder:</p>
<pre><code>Pack
 +-- MyApp
      |-- MyApp.deps.json
      |-- MyApp.dll
      |-- MyApp.pdb
      \-- MyApp.runtimeconfig.json
</code></pre>
<h4 id="include-files">Include Files</h4>
<p>We can also include extra files into our output folder. For instances, lets add a <code>README.md</code> file beside our <code>program.cs</code> file.</p>
<pre><code>MyNewApp
========

version 1.0.0

This app prints the first verse of a poem.
</code></pre>
<p>In our <code>csproj</code> file we can use the <a href="https://docs.microsoft.com/en-nz/nuget/reference/msbuild-targets#including-content-in-a-package">standard MSBuild settings</a> for adding files.</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;Content Include=&quot;README.md&quot; CopyToPublishDirectory=&quot;Always&quot; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;

</code></pre>
<pre><code>dotnet publish -o &quot;../Pack/MyApp&quot; -c Release
</code></pre>
<p>That&rsquo;s how easy it is to include extra files when publishing.</p>
<h3 id="publishing-net-452-applications">Publishing .Net 4.5.2 applications</h3>
<p>Or 4.6, 4.6.2 &amp; 4.7. They all basically follow the same principles.</p>
<p>It all starts with the <code>csproj</code> file. For reality sake, I am going to add to rather than replace the <code>netcoreapp2.0</code> target (as seen in <a href="/dotnetcore2-multi-targeting">the last article</a>).</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFrameworks&gt;netcoreapp2.0;net452&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;
  
  &lt;ItemGroup&gt;
    &lt;Content Include=&quot;README.md&quot; CopyToPublishDirectory=&quot;Always&quot; /&gt;
  &lt;/ItemGroup&gt;

&lt;/Project&gt;
</code></pre>
<pre><code>dotnet build  
dotnet publish -o &quot;..\Pack\MyApp_Net452&quot; -c Release -f net452
</code></pre>
<p>Your Pack folder should now have two packaged application folders like the following:</p>
<pre><code>Pack
 +-- MyApp
 |    |-- MyApp.deps.json
 |    |-- MyApp.dll
 |    |-- MyApp.pdb
 |    |-- MyApp.runtimeconfig.json
 |    \-- README.md
 +-- MyApp_Net452
     |-- MyApp.exe
     |-- MyApp.pdb
     \-- README.md
</code></pre>
<p>We now have a <code>.Net 4.5.2</code> <code>EXE</code> that we can run anywhere where <code>.Net 4.5.2</code> has been installed.</p>
<p>One thing missing is an <code>App.Config</code>, which some of your existing applications likely use for useful things like configuration. You can simply add an include with a transform to map a file called <code>App.Config</code>, with a transformation to the more expected name of <code>%APPNAME%.exe.config</code>. (Although there are <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?tabs=basicconfiguration">now better ways to do config</a>, you may find this useful as a transition path.)</p>
<p>Add our <code>App.Config</code> file.</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;configuration&gt;
  &lt;appSettings&gt;
    &lt;!-- Settings go here, you know how to use them already? --&gt;
  &lt;/appSettings&gt;
&lt;/configuration&gt;
</code></pre>
<p>And that&rsquo;s it. As on <code>SDK 2.1</code> that I am using, this is automatically loaded and used the same as it was in classic .Net.</p>
<pre><code>dotnet build
dotnet publish -f net452
dotnet publish -f netcoreapp2.0
</code></pre>
<p>Remember, if you use <code>build</code>, <code>pack</code>, or <code>publish</code> without using <code>-f &lt;framework&gt;</code> you will get all target frameworks included. (And if you use <code>-f</code> and <code>-o</code> together with <code>publish</code>, it will dump the targets' output on top of each other in the same folder. Probably don&rsquo;t do that.)</p>
<p>Let&rsquo;s take one last look at the file tree in the <code>MyApp</code> project folder:</p>
<pre><code>MyPackagedApp
 +-- MyApp
      |-- MyApp.csproj
      |-- Program.cs
      +-- bin
           +-- Debug
                +-- net452
                |    |-- MyApp.exe
                |    |-- MyApp.exe.config
                |    |-- MyApp.pdb
                |    +-- publish
                |         |-- MyApp.exe
                |         |-- MyApp.exe.config
                |         |-- MyApp.pdb
                |         \-- README.md
                +-- netcoreapp2.0
                     |-- MyApp.deps.json
                     |-- MyApp.dll
                     |-- MyApp.dll.config
                     |-- MyApp.pdb
                     |-- MyApp.runtimeconfig.dev.json
                     |-- MyApp.runtimeconfig.json
                     +-- publish
                          |-- MyApp.deps.json
                          |-- MyApp.dll
                          |-- MyApp.dll.config
                          |-- MyApp.pdb
                          |-- MyApp.runtimeconfig.json
                          \-- README.md
</code></pre>
<p>Inside our publish folders, which are our <code>publish</code> outputs, it includes both the earlier <code>README.md</code> and the transformed <code>app.config</code> file ready to zip up and distribute as required.</p>
<p>In reality, you might have to look for a bridging library to actually load the <code>app.config</code> in <code>netcoreapp2.0</code> but I haven&rsquo;t tried that recently so I leave that to you, if you want/need it. Investigate the <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?tabs=basicconfiguration">new configuration</a>. Really.</p>
<h3 id="onward-to-the-finish">Onward to the finish!</h3>
<p>We are almost wrapped up, only one last piece to go, Self-contained Applications. Stay tuned.</p>
</description>
    </item>
    
    <item>
      <title>.Net Core SDK 2.* Series - Multi-targeting</title>
      <link>https://csmacnzblog.github.io/post/dotnetcore2-multi-targeting/</link>
      <pubDate>Tue, 06 Mar 2018 22:35:53 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/dotnetcore2-multi-targeting/</guid>
      <description><p>This is a series on the latest 2.* .Net Core bits, Following on from the original <a href="https://blog.csmac.nz/dotnetcore-getting-started">.Net Core Series</a></p>
<ul>
<li><a href="/dotnetcore2-getting-started">Getting Started</a></li>
<li><a href="/dotnetcore2-whats-in-the-box">What&rsquo;s in the box</a></li>
<li><a href="/dotnetcore2-using-multiple-projects">Using Multiple Projects</a></li>
<li><a href="/dotnetcore2-testing">Testing</a></li>
<li><a href="/dotnetcore2-nuget">NuGet</a></li>
<li>Multi-targeting &lt;=(We are here)</li>
<li><a href="/dotnetcore2-publishing-portable-applications">Publishing Portable Applications</a></li>
<li><a href="/dotnetcore2-self-contained-applications">Self-contained Applications</a></li>
</ul>
<p>(At the time of writing, 2.1.4. I use windows, you don&rsquo;t have to!)</p>
<p><a href="/dotnetcore2-nuget">Last time</a> we learned how to package our libraries as NuGet packages. But it was only targeting <code>netstandard2.0</code>, the <code>netstandard</code> target framework moniker for version 2.0.</p>
<h3 id="a-quick-reference">A Quick Reference</h3>
<p>All the old profiles and platforms have been mapped to netstandard target versions. This allows you to choose a version of <code>netstandard*</code> to target that will be compatible with a minimum version of a specific platform runtime.  Take a look at <a href="https://github.com/dotnet/standard/blob/master/docs/versions.md">dotnet standard versions</a> page for both framework and PCL mappings to <code>netstandard</code> versions.</p>
<p>If you implement a particular target version in your package, it can be used by other libraries that are compatible with an equal or higher version level.</p>
<p>The main catch is that whichever version of <code>netstandard</code> you choose, you will be limited to that version&rsquo;s set of APIs in your code, and will not be able to use any API methods, classes or properties that are not in that version.</p>
<p>A very comprehensive list of Target Frameworks can be found in the docs on the <a href="https://docs.microsoft.com/en-nz/nuget/reference/target-frameworks">target frameworks reference</a> page.  You may wish to refer to this going forward, but it is not necessary to read it now.</p>
<p>But as we will see, we are not limited to one version, or even to just <code>netstandard</code>.</p>
<h3 id="setup">Setup</h3>
<p>If you have been following the series right through, you should be able to follow what the next script does to set up our starting project:</p>
<pre><code>mkdir MyNewPackage
cd MyNewPackage
mkdir MyLib
cd MyLib
dotnet new classlib
cd ../
dotnet new sln
dotnet sln add ./MyLib/MyLib.csproj
dotnet build
</code></pre>
<p>Like before, you may wish to replace <code>Class1.cs</code> with a <code>Calculator</code> class.</p>
<pre><code>using System;

namespace MyLib
{
    public class Calculator
    {
        public int Add(int first, int second)
        {
            return first + second;
        }
    }
}
</code></pre>
<p>And one more:</p>
<pre><code>dotnet build
</code></pre>
<h3 id="on-with-the-show">On with the show!</h3>
<p>This all boils down to one XML Element inside the <code>*.csproj</code> file.</p>
<p>Starting with the initial <code>MyLib.csproj</code> file:</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>Say we wanted to target <code>netstandard1.0</code> instead. It would be as simple as changing <code>&quot;netstandard2.0&quot;</code> to <code>&quot;netstandard1.0&quot;</code>. We&rsquo;ve covered this, and it works fine.</p>
<p>Now let&rsquo;s say we want to use some <code>netstandard2.0</code> features if they are available. But we also want to be compatible with <code>netstandard1.0</code>, with limited functionality, or alternative features used.  We would do this to our <code>csproj</code>.</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFrameworks&gt;netstandard1.0;netstandard2.0&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>Note that we changed <code>&lt;TargetFramework&gt;</code> to <code>&lt;TargetFrameworks&gt;</code>, plural (briefly mentioned <a href="https://blog.csmac.nz/dotnetcore2-whats-in-the-box/#targetframeworks">earlier on in the series</a>). And by adding new frameworks, we can target multiple platforms. By default, a build will now build all the frameworks, (but there are arguments that allow us to target only one or the other during build).</p>
<p>So let&rsquo;s run a rebuild with this change:</p>
<pre><code>dotnet build
</code></pre>
<pre><code>Microsoft (R) Build Engine version 15.5.180.51428 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restoring packages for C:\dev\MyNewPackage\MyLib\MyLib.csproj...
  Generating MSBuild file C:\dev\MyNewPackage\MyLib\obj\MyLib.csproj.nuget.g.targets.
  Restore completed in 471.53 ms for C:\dev\MyNewPackage\MyLib\MyLib.csproj.
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard1.0\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard2.0\MyLib.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:03.26
</code></pre>
<p>specifically note the two lines near the end:</p>
<pre><code>MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard1.0\MyLib.dll
MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard2.0\MyLib.dll
</code></pre>
<p>What does this do to our file tree?</p>
<pre><code>MyNewPackage
|-- MyNewPackage.sln
+-- MyLib
     |-- Class1.cs
     |-- MyLib.csproj
     +-- bin
          +-- Debug
               +-- netstandard1.0
               |    |-- MyLib.deps.json
               |    |-- MyLib.dll
               |    \-- MyLib.pdb
               +-- netstandard2.0
                    |-- MyLib.deps.json
                    |-- MyLib.dll
                    \-- MyLib.pdb
</code></pre>
<p>We now have two target outputs, and two <code>dll</code> files, which target different frameworks.</p>
<h3 id="dependencies">Dependencies</h3>
<p>When we add Dependencies to our project, as <a href="/dotnetcore2-whats-in-the-box/#frameworksanddependencies">discussed before</a>, but it is worth noting that by default they apply to all targets. Since we have only had one target until now that hasn&rsquo;t been an explicit thing, but we have two targets in this example.</p>
<p>We don&rsquo;t have to add the dependency to every target, however. We can choose to add dependencies to only a specific target framework using some of the MSBuild features available to us.  (This applies to other references too, but I won&rsquo;t cover that here)</p>
<p>Say that we want to reference Json.Net, but only if we are targetting <code>netstandard2.0</code>. This will mean that the library isn&rsquo;t available to our <code>netstandard1.0</code> version, (and so we would have to conditionally compile out any code that used it), but it would mean that anyone using this library with a <code>netstandard1.0</code> compatible target would not need the NuGet reference or its library. (A bit contrived, but the main thing to show you is the syntax. In reality, it is more likely you have a library that doesn&rsquo;t support <code>netstandard1.0</code> and you want graceful degradation on older targets).</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFrameworks&gt;netstandard1.0;netstandard2.0&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup Condition=&quot; '$(TargetFramework)' == 'netstandard2.0' &quot;&gt;
    &lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;11.0.1&quot; /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>you can add as many or as few <code>Condition</code> clauses as you need, and this creates conditional PackageReferences, depending on which <code>TargetFramwork</code> is being built at the time.</p>
<h3 id="conditional-compilation">Conditional Compilation</h3>
<p>If we are targeting different frameworks, we likely have to adjust the code as well. We do this using compiler preprocessor symbols.</p>
<p>We get a bunch of symbols created for us, and each target framework will create a few at compile-time automatically for you. We can use these to conditionally compile parts of our code:</p>
<pre><code>#if NETSTANDARD2_0
        //Extra code for netstandard
        var x = 0;
        //...Something using Newtonsoft.Json...
#endif
</code></pre>
<p>More information on using compiler preprocessor symbols can be found <a href="https://docs.microsoft.com/en-us/dotnet/standard/frameworks">here</a>.</p>
<h3 id="packaging">Packaging</h3>
<p>Packaging into a <code>nupkg</code> file works the same as before.</p>
<pre><code>dotnet pack
</code></pre>
<pre><code>Microsoft (R) Build Engine version 15.5.180.51428 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restore completed in 32.28 ms for C:\dev\MyNewPackage\MyLib\MyLib.csproj.
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard1.0\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard2.0\MyLib.dll
  Successfully created package 'C:\dev\MyNewPackage\MyLib\bin\Debug\MyLib.1.0.0.nupkg'.
</code></pre>
<p>And results in a new file:</p>
<pre><code>MyNewPackage
|-- MyNewPackage.sln
+-- MyLib
     |-- Class1.cs
     |-- MyLib.csproj
     +-- bin
          +-- Debug
               |-- MyLib.1.0.0.nupkg
               +-- netstandard1.0
               |    |-- MyLib.deps.json
               |    |-- MyLib.dll
               |    \-- MyLib.pdb
               +-- netstandard2.0
                    |-- MyLib.deps.json
                    |-- MyLib.dll
                    \-- MyLib.pdb
</code></pre>
<p>Instead of getting a package per target, we get one package that contains both targets.</p>
<pre><code>MyLib.1.0.0.nupkg  
|-- MyLib.nuspec
+-- lib
     +-- netstandard1.0
     |    \-- MyLib.dll
     +-- netstandard1.6
          \-- MyLib.dll
</code></pre>
<h3 id="a-sidenote-on-running">A sidenote on running</h3>
<p>You can also use multi-targeting on an application. When you want to run an application with multiple targets, you can use the <code>dotnet run</code> command with the <code>-f &lt;target&gt;</code> flag option.</p>
<pre><code>dotnet run -f netcoreapp1.0
</code></pre>
<p>Of course, <code>netcoreapp1.0</code> is the application target for the .Net Core runtime, compared to using <code>net45</code> perhaps to target .Net 4.5 runtime instead.</p>
<h3 id="net40">net40</h3>
<p>The target <code>netstandard1.0</code> is compatible with .Net 4.5 and newer, UWP apps, Windows 8 &amp; Windows Phone 8 or newer, Mono 4.6 and certain Xamarin versions, and of course new .Net Core applications. Also, <code>netstandard2.0</code> is compatible with .Net 4.6.1 and newer, newer UWP versions, Mono 5.4 and newer Xamarin versions, and .Net Core 2.0+.  But we all know that there are a ton of applications out there targeting .Net 4.0, and even .Net 3.5 that we still maintain and support that we might want our library packages to target. (Yes, still. It is out of support but that doesn&rsquo;t stop some people&hellip; -<a href="https://blogs.msdn.microsoft.com/dotnet/2015/12/09/support-ending-for-the-net-framework-4-4-5-and-4-5-1/">so is 4.5 now</a>, BTW)</p>
<p>But we can easily target net40 and net35 as well (though not net35 on my windows 10 machine&hellip; without some extra SDKs installed).</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFrameworks&gt;netstandard1.0;netstandard2.0;net45;net40&lt;/TargetFrameworks&gt;
  &lt;/PropertyGroup&gt;

  &lt;ItemGroup Condition=&quot; '$(TargetFramework)' == 'netstandard2.0' &quot;&gt;
    &lt;PackageReference Include=&quot;Newtonsoft.Json&quot; Version=&quot;11.0.1&quot; /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;
</code></pre>
<p>This simple library doesn&rsquo;t need anything outside the standard library, but if it did, we would add in target-specific packages and libraries to the <code>net40</code> and <code>net45</code> targets as well.</p>
<pre><code>dotnet build
</code></pre>
<pre><code>Microsoft (R) Build Engine version 15.5.180.51428 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restoring packages for C:\dev\MyNewPackage\MyLib\MyLib.csproj...
  Restore completed in 174.61 ms for C:\dev\MyNewPackage\MyLib\MyLib.csproj.
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard1.0\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\net40\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\net45\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard2.0\MyLib.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:03.37
</code></pre>
<p>We can pack this.</p>
<pre><code>dotnet pack
</code></pre>
<pre><code>Microsoft (R) Build Engine version 15.5.180.51428 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restore completed in 29.08 ms for C:\dev\MyNewPackage\MyLib\MyLib.csproj.
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard1.0\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\net40\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\net45\MyLib.dll
  MyLib -&gt; C:\dev\MyNewPackage\MyLib\bin\Debug\netstandard2.0\MyLib.dll
  Successfully created package 'C:\dev\MyNewPackage\MyLib\bin\Debug\MyLib.1.0.0.nupkg'.
</code></pre>
<p>Then we will get:</p>
<pre><code>MyNewPackage
|-- MyNewPackage.sln
+-- MyLib
     |-- Class1.cs
     |-- MyLib.csproj
     +-- bin
          +-- Debug
               |-- MyLib.1.0.0.nupkg
               +-- net40
               |    |-- MyLib.dll
               |    \-- MyLib.pdb
               +-- net45
               |    |-- MyLib.dll
               |    \-- MyLib.pdb
               +-- netstandard1.0
               |    |-- MyLib.deps.json
               |    |-- MyLib.dll
               |    \-- MyLib.pdb
               +-- netstandard2.0
                    |-- MyLib.deps.json
                    |-- MyLib.dll
                    \-- MyLib.pdb
</code></pre>
<p>And:</p>
<pre><code>MyLib.1.0.0.nupkg  
|-- MyLib.nuspec
+-- lib
     +-- net40
     |    \-- MyLib.dll
     +-- net45
     |    \-- MyLib.dll
     +-- netstandard1.0
     |    \-- MyLib.dll
     +-- netstandard1.6
          \-- MyLib.dll
</code></pre>
<h3 id="whats-left">What&rsquo;s Left?</h3>
<p>That should give you a reasonable (albeit simple) overview of multi-targeting libraries.  The last focus is on applications, and how we publish and distribute these using the dotnet CLI tools.  Up Next!</p>
</description>
    </item>
    
    <item>
      <title>.Net Core SDK 2.* Series - NuGet</title>
      <link>https://csmacnzblog.github.io/post/dotnetcore2-nuget/</link>
      <pubDate>Mon, 19 Feb 2018 04:00:00 +0000</pubDate>
      
      <guid>https://csmacnzblog.github.io/post/dotnetcore2-nuget/</guid>
      <description><p>This is a series on the latest 2.* .Net Core bits, Following on from the original <a href="https://blog.csmac.nz/dotnetcore-getting-started">.Net Core Series</a></p>
<ul>
<li><a href="/dotnetcore2-getting-started">Getting Started</a></li>
<li><a href="/dotnetcore2-whats-in-the-box">What&rsquo;s in the box</a></li>
<li><a href="/dotnetcore2-using-multiple-projects">Using Multiple Projects</a></li>
<li><a href="/dotnetcore2-testing">Testing</a></li>
<li>NuGet &lt;=(We are here)</li>
<li><a href="/dotnetcore2-multi-targeting">Multi-targeting</a></li>
<li><a href="/dotnetcore2-publishing-portable-applications">Publishing Portable Applications</a></li>
<li><a href="/dotnetcore2-self-contained-applications">Self-contained Applications</a></li>
</ul>
<p>(At the time of writing, 2.1.4. I use windows, you don&rsquo;t have to!)</p>
<p>Let&rsquo;s set aside Application packing for later, and focus our attention on NuGet.</p>
<h3 id="our-demo-library">Our Demo library</h3>
<p>Again we will quickly whip up a library to use:</p>
<pre><code>mkdir MyPackageRepo
cd MyPackageRepo
mkdir MyLib
cd MyLib
dotnet new classlib
cd ../
dotnet new sln
dotnet sln add ./MyLib/MyLib.csproj
dotnet build
</code></pre>
<p>Some quick touch-ups to make it more interesting. Replace <code>.\MyLib\Class1.cs</code> with this again:</p>
<pre><code>using System;

namespace MyLib
{
    public class Calculator
    {
        public int Add(int first, int second)
        {
            return first + second;
        }
    }
}
</code></pre>
<p>At least now our package contains something interesting. One more <code>dotnet build</code> to ensure our code is correct.</p>
<pre><code>dotnet build
</code></pre>
<pre><code>Microsoft (R) Build Engine version 15.5.180.51428 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restore completed in 15.94 ms for C:\dev\MyPackageRepo\MyLib\MyLib.csproj.
  MyLib -&gt; C:\dev\MyPackageRepo\MyLib\bin\Debug\netstandard2.0\MyLib.dll

Build succeeded.
    0 Warning(s)
    0 Error(s)

Time Elapsed 00:00:01.80
</code></pre>
<h3 id="simple-packing">Simple Packing</h3>
<p>It isn&rsquo;t very difficult to turn our library into a <code>nupkg</code> (pronounced <a href="https://twitter.com/csharpfritz/status/519927456191758336">NUP-KEG</a>, of course).</p>
<pre><code>dotnet pack
</code></pre>
<pre><code>Microsoft (R) Build Engine version 15.5.180.51428 for .NET Core
Copyright (C) Microsoft Corporation. All rights reserved.

  Restore completed in 15.86 ms for C:\dev\MyPackageRepo\MyLib\MyLib.csproj.
  MyLib -&gt; C:\dev\MyPackageRepo\MyLib\bin\Debug\netstandard2.0\MyLib.dll
  Successfully created package 'C:\dev\MyPackageRepo\MyLib\bin\Debug\MyLib.1.0.0.nupkg'.
</code></pre>
<p>This leaves us with a directory structure like so:</p>
<pre><code>MyPackageRepo
|-- nugetdemo.sln
+-- MyLib
     |-- Class1.cs
     |-- MyLib.csproj
     +-- bin
          +-- Debug
               |-- MyLib.1.0.0.nupkg
               +-- netstandard2.0
                    |-- MyLib.deps.json
                    |-- MyLib.dll
                    \-- MyLib.pdb
</code></pre>
<p>(Note that I have left out the <code>obj</code> folder), we can see a new file has been created under <code>/bin/Debug</code>, called <code>MyLib.1.0.0.nupkg</code>.</p>
<p>This is a NuGet package (<code>nupkg</code>). Pretty easy huh?  The default version number comes from the <code>*.csproj</code> file. (More on that soon.)</p>
<p>But that was a <code>Debug</code> build. To produce a release build instead:</p>
<pre><code>dotnet pack -c Release
</code></pre>
<p>Now we have more new files:</p>
<pre><code>MyPackageRepo
|-- nugetdemo.sln
+-- MyLib
     |-- Class1.cs
     |-- MyLib.csproj
     +-- bin
          +-- Debug
          |    |-- MyLib.1.0.0.nupkg
          |    +-- netstandard2.0
          |         |-- MyLib.deps.json
          |         |-- MyLib.dll
          |         \-- MyLib.pdb
          +-- Release
               |-- MyLib.1.0.0.nupkg
               +-- netstandard2.0
                    |-- MyLib.deps.json
                    |-- MyLib.dll
                    \-- MyLib.pdb
</code></pre>
<p>We can see that we now have a <code>Release</code> folder (containing a <code>netstandard2.0</code> folder, thanks to an automatic build before the pack) and in the <code>Release</code> folder, we again have a <code>MyLib.1.0.0.nupkg</code> file.</p>
<h3 id="crack-open-a-nupkg">Crack open a nupkg</h3>
<p>What do these <code>nupkg</code> files look like on the inside? Using a tool like <a href="https://github.com/NuGetPackageExplorer/NuGetPackageExplorer">NuGet Package Explorer</a> we can take a look. The Release version looks like this:</p>
<pre><code>MyLib.1.0.0.nupkg
|-- MyLib.nuspec
+-- lib
     +-- netstandard2.0
          \-- MyLib.dll
</code></pre>
<p>Some things to observe. We only have a lib file for <code>netstandard2.0</code> target profile. This means that our NuGet package only works with new .Net Core applications compatible with NetStandard2.0 or newer. (Remember that <a href="https://github.com/dotnet/standard/blob/master/docs/versions.md">version compatibility table?</a>)</p>
<p>Changing our attention to the contents of the <code>nuspec</code> file:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;package xmlns=&quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;&gt;
  &lt;metadata&gt;
    &lt;id&gt;MyLib&lt;/id&gt;
    &lt;version&gt;1.0.0&lt;/version&gt;
    &lt;authors&gt;MyLib&lt;/authors&gt;
    &lt;owners&gt;MyLib&lt;/owners&gt;
    &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt;
    &lt;description&gt;Package Description&lt;/description&gt;
    &lt;dependencies&gt;
      &lt;group targetFramework=&quot;.NETStandard2.0&quot; /&gt;
    &lt;/dependencies&gt;
  &lt;/metadata&gt;
&lt;/package&gt;
</code></pre>
<p>We didn&rsquo;t add any extra settings our <code>*.csproj</code> file. But we can see here that the <code>csproj</code> and project folder name <code>MyLib</code> is used to populate the package <code>id</code>, <code>authors</code> and <code>owners</code>. Let&rsquo;s remind ourselves what the <code>csproj</code> looks like:</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>We also see that under dependencies there is a group for the <code>targetFramework</code> <code>&quot;.NETStandard2.0&quot;</code>, although currently, it has no dependencies.</p>
<h3 id="custom-metadata">Custom Metadata</h3>
<p>We looked at some of the <code>csproj</code> metadata in <a href="/dotnetcore2-whats-in-the-box/#metadata">Part 2, what&rsquo;s in the box</a>. We saw you could set the following properties:</p>
<pre><code>&lt;PropertyGroup&gt;
    &lt;Authors&gt;csMACnz&lt;/Authors&gt;
    &lt;NeutralLanguage&gt;en-NZ&lt;/NeutralLanguage&gt;
    &lt;Company&gt;csMACnz&lt;/Company&gt;
    &lt;Product&gt;MyApp&lt;/Product&gt;
    &lt;Copyright&gt;Copyright © csMACnz 2018&lt;/Copyright&gt;
  &lt;/PropertyGroup&gt;
</code></pre>
<p>These will map metadata into our NuGet package. Let&rsquo;s learn some more properties before we try generating a new <code>nupkg</code>.</p>
<p>We have <code>AssemblyTitle</code>, <code>Title</code>, and <code>Description</code> that out <code>nupkg</code> can take advantage of (as well as other build processes that might want them, such as the <code>dll</code> name).  We also have some <code>Package*</code> properties specifically for packages. <code>PackageId</code>, <code>PackageRequireLicenseAcceptance</code>, <code>PackageLicenseUrl</code>, <code>PackageIconUrl</code>, <code>PackageTags</code> <code>PackageVersion</code> and <code>PackageReleaseNotes</code>.</p>
<p>Special mention for <code>PackageVersion</code>. This is optional, and by default, the <code>Version</code> property value will be used. You can explicitly add <code>Version</code>, or it will implicitly be <code>1.0.0</code>, as we saw earlier on.</p>
<p>We can now update our <code>csproj</code> to look like this:</p>
<pre><code>&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;

  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard2.0&lt;/TargetFramework&gt;
    &lt;Authors&gt;dev-markc&lt;/Authors&gt;
    &lt;NeutralLanguage&gt;en-NZ&lt;/NeutralLanguage&gt;
    &lt;Company&gt;csMACnz&lt;/Company&gt;
    &lt;Product&gt;MyLib Product&lt;/Product&gt;
    &lt;Copyright&gt;Copyright © csMACnz 2018&lt;/Copyright&gt;
    &lt;AssemblyTitle&gt;MyLib.Title&lt;/AssemblyTitle&gt;
    &lt;Title&gt;MyLib - Cool Stuff Here&lt;/Title&gt;
    &lt;Description&gt;MyLib - A library that does cool things with stuff.&lt;/Description&gt;
    &lt;PackageId&gt;MyLib.PackageId&lt;/PackageId&gt;
    &lt;PackageRequireLicenseAcceptance&gt;false&lt;/PackageRequireLicenseAcceptance&gt;
    &lt;PackageLicenseUrl&gt;https://myprojectwebsite.uri/projects/MyLib/LICENSE&lt;/PackageLicenseUrl&gt;
    &lt;PackageProjectUrl&gt;https://myprojectwebsite.uri/projects/MyLib&lt;/PackageProjectUrl&gt;
    &lt;PackageIconUrl&gt;https://myprojectwebsite.uri/icons/mylib.png&lt;/PackageIconUrl&gt;
    &lt;PackageTags&gt;sample test lib stuff things&lt;/PackageTags&gt;
    &lt;PackageVersion&gt;1.2.3&lt;/PackageVersion&gt;
    &lt;PackageReleaseNotes&gt;These are sample release notes for this version&lt;/PackageReleaseNotes&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre>
<p>And again we pack, and review the <code>nuspec</code> file inside the generated <code>nupkg</code>.</p>
<pre><code>dotnet pack -c Release
</code></pre>
<p>This time, we have a <code>MyLib.PackageId.1.2.3.nupkg</code> file, which is because we used <code>PackageId</code> to get <code>MyLib.PackageId</code> and <code>PackageVersion</code> to get the <code>1.2.3</code>.</p>
<p>Inside the <code>MyLib.PackageId.1.2.3.nupkg</code> there is a <code>MyLib.PackageId.nuspec</code> which looks like the followiing:</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;package xmlns=&quot;http://schemas.microsoft.com/packaging/2012/06/nuspec.xsd&quot;&gt;
  &lt;metadata&gt;
    &lt;id&gt;MyLib.PackageId&lt;/id&gt;
    &lt;version&gt;1.2.3&lt;/version&gt;
    &lt;title&gt;MyLib - Cool Stuff Here&lt;/title&gt;
    &lt;authors&gt;dev-markc&lt;/authors&gt;
    &lt;owners&gt;dev-markc&lt;/owners&gt;
    &lt;requireLicenseAcceptance&gt;false&lt;/requireLicenseAcceptance&gt;
    &lt;licenseUrl&gt;https://myprojectwebsite.uri/projects/MyLib/LICENSE&lt;/licenseUrl&gt;
    &lt;projectUrl&gt;https://myprojectwebsite.uri/projects/MyLib&lt;/projectUrl&gt;
    &lt;iconUrl&gt;https://myprojectwebsite.uri/icons/mylib.png&lt;/iconUrl&gt;
    &lt;description&gt;MyLib - A library that does cool things with stuff.&lt;/description&gt;
    &lt;releaseNotes&gt;These are sample release notes for this version&lt;/releaseNotes&gt;
    &lt;copyright&gt;Copyright © csMACnz 2018&lt;/copyright&gt;
    &lt;tags&gt;sample test lib stuff things&lt;/tags&gt;
    &lt;dependencies&gt;
      &lt;group targetFramework=&quot;.NETStandard2.0&quot; /&gt;
    &lt;/dependencies&gt;
  &lt;/metadata&gt;
&lt;/package&gt;
</code></pre>
<p>Most mappings from <code>csproj</code> to <code>nuspec</code> are self-explanatory. Also, some are not used here (<code>Product</code>, <code>Company</code>, <code>AssemblyTitle</code>) but you will find these as metadata on the <code>dll</code> instead.</p>
<p>I haven&rsquo;t been completely comprehensive here. The full documentation of the NuGet metadata properties is <a href="https://docs.microsoft.com/en-us/dotnet/core/tools/csproj#nuget-metadata-properties">in the docs</a>.</p>
<h3 id="and-the-next-time">And the next time&hellip;</h3>
<p>We can build packages to be used by new .Net Core applications and <code>NetStandard2.0</code> compatible application. But we probably want to build libraries that can be used from older .Net 4.0, Windows Phone, older UWP applications and .Net Core 1.0 apps as well.  Next up, we see how to extend our package to handle just these situations.</p>
</description>
    </item>
    
  </channel>
</rss>